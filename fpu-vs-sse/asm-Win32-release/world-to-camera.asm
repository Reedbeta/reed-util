; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Source\reed-util\fpu-vs-sse\world-to-camera.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?calcWorldToCamera_FPU@@YAXMMQBMQAY03M@Z	; calcWorldToCamera_FPU
PUBLIC	?calcWorldToCamera_SSE_aos@@YAXMMABT__m128@@QAT1@@Z ; calcWorldToCamera_SSE_aos
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	_memset:PROC
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp
;	COMDAT ?calcWorldToCamera_SSE_aos@@YAXMMABT__m128@@QAT1@@Z
_TEXT	SEGMENT
_vecUp$ = -48						; size = 16
_vecView$ = -32						; size = 16
_sinPitch$1$ = -12					; size = 4
_sinYaw$1$ = -8						; size = 4
_cosYaw$1$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
_cameraPos$ = 16					; size = 4
_outWorldToCamera$ = 20					; size = 4
?calcWorldToCamera_SSE_aos@@YAXMMABT__m128@@QAT1@@Z PROC ; calcWorldToCamera_SSE_aos, COMDAT

; 73   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	movss	xmm0, DWORD PTR _yaw$[ebx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 430  :         {return ((float)sin((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sinYaw$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _yaw$[ebx]

; 410  :         {return ((float)cos((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cosYaw$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _pitch$[ebx]

; 430  :         {return ((float)sin((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sinPitch$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _pitch$[ebx]

; 410  :         {return ((float)cos((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp

; 80   : 	__m128 vecView = { cosYaw * cosPitch, sinYaw * cosPitch, sinPitch };

	movss	xmm3, DWORD PTR _sinPitch$1$[ebp]
	xorps	xmm2, xmm2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 410  :         {return ((float)cos((double)_X)); }

	cvtsd2ss xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp

; 91   : 	outWorldToCamera[0] = vecView;

	mov	ecx, DWORD PTR _outWorldToCamera$[ebx]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _cosYaw$1$[ebp]
	movss	DWORD PTR _vecView$[ebp+8], xmm3
	movss	DWORD PTR _vecUp$[ebp+8], xmm2
	movss	DWORD PTR _vecView$[ebp], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _sinYaw$1$[ebp]

; 92   : 	outWorldToCamera[1] = vecLeft;
; 93   : 	outWorldToCamera[2] = vecUp;
; 94   : 	outWorldToCamera[3] = _mm_setzero_ps();
; 95   : 	_MM_TRANSPOSE4_PS(outWorldToCamera[0], outWorldToCamera[1], outWorldToCamera[2], outWorldToCamera[3]);
; 96   : 
; 97   : 	// Calculate inverse translation, -cameraPos * outWorldToCamera
; 98   : 	__m128 cameraPosX = _mm_shuffle_ps(cameraPos, cameraPos, _MM_SHUFFLE(0,0,0,0));

	mov	eax, DWORD PTR _cameraPos$[ebx]
	mov	DWORD PTR _vecView$[ebp+12], 0
	movss	DWORD PTR _vecView$[ebp+4], xmm0
	movaps	xmm7, XMMWORD PTR _vecView$[ebp]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _cosYaw$1$[ebp]
	mulss	xmm3, DWORD PTR _sinYaw$1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _vecUp$[ebp], xmm0
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _vecUp$[ebp+4], xmm3
	mov	DWORD PTR _vecUp$[ebp+12], 0
	movaps	xmm5, XMMWORD PTR _vecUp$[ebp]
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 18				; 00000012H
	movaps	xmm2, xmm5
	shufps	xmm2, xmm5, 9
	mulps	xmm2, xmm0
	movaps	xmm0, xmm7
	shufps	xmm0, xmm7, 9
	movaps	xmm1, xmm5
	shufps	xmm1, xmm5, 18				; 00000012H
	mulps	xmm1, xmm0
	movaps	XMMWORD PTR [ecx], xmm7
	movaps	xmm4, xmm7
	xorps	xmm6, xmm6
	subps	xmm2, xmm1
	movaps	XMMWORD PTR [ecx+32], xmm5
	movaps	xmm0, xmm5
	shufps	xmm0, xmm6, 68				; 00000044H
	shufps	xmm5, xmm6, 238				; 000000eeH
	shufps	xmm7, xmm2, 238				; 000000eeH
	movaps	XMMWORD PTR [ecx+16], xmm2
	shufps	xmm4, xmm2, 68				; 00000044H
	movaps	xmm2, xmm4
	shufps	xmm2, xmm0, 136				; 00000088H
	shufps	xmm4, xmm0, 221				; 000000ddH
	movaps	xmm3, xmm7
	shufps	xmm3, xmm5, 136				; 00000088H
	shufps	xmm7, xmm5, 221				; 000000ddH
	movaps	XMMWORD PTR [ecx], xmm2
	movaps	XMMWORD PTR [ecx+16], xmm4
	movaps	XMMWORD PTR [ecx+32], xmm3
	movaps	XMMWORD PTR [ecx+48], xmm7
	movaps	xmm1, XMMWORD PTR [eax]
	movaps	xmm0, xmm1
	shufps	xmm0, xmm1, 0

; 99   : 	__m128 cameraPosY = _mm_shuffle_ps(cameraPos, cameraPos, _MM_SHUFFLE(1,1,1,1));
; 100  : 	__m128 cameraPosZ = _mm_shuffle_ps(cameraPos, cameraPos, _MM_SHUFFLE(2,2,2,2));
; 101  : 	__m128 invTranslation = _mm_setzero_ps();
; 102  : 	invTranslation = _mm_sub_ps(invTranslation, _mm_mul_ps(cameraPosX, outWorldToCamera[0]));

	mulps	xmm0, xmm2
	subps	xmm6, xmm0
	movaps	xmm0, xmm1
	shufps	xmm0, xmm1, 85				; 00000055H

; 103  : 	invTranslation = _mm_sub_ps(invTranslation, _mm_mul_ps(cameraPosY, outWorldToCamera[1]));

	mulps	xmm0, xmm4
	shufps	xmm1, xmm1, 170				; 000000aaH
	subps	xmm6, xmm0

; 104  : 	invTranslation = _mm_sub_ps(invTranslation, _mm_mul_ps(cameraPosZ, outWorldToCamera[2]));

	mulps	xmm1, xmm3
	subps	xmm6, xmm1

; 105  : 
; 106  : 	// Stuff it in the matrix, with final component = 1.0
; 107  : 	outWorldToCamera[3] = invTranslation;

	movaps	XMMWORD PTR [ecx+48], xmm6

; 108  : 	outWorldToCamera[3].m128_f32[3] = 1.0f;

	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H

; 109  : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?calcWorldToCamera_SSE_aos@@YAXMMABT__m128@@QAT1@@Z ENDP ; calcWorldToCamera_SSE_aos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp
;	COMDAT ?calcWorldToCamera_FPU@@YAXMMQBMQAY03M@Z
_TEXT	SEGMENT
_vecLeft$3$ = -28					; size = 4
_vecLeft$2$ = -24					; size = 4
_vecView$2$ = -20					; size = 4
_cosPitch$1$ = -16					; size = 4
_vecUp$2$ = -12						; size = 4
_cosYaw$1$ = -12					; size = 4
_vecUp$1$ = -8						; size = 4
_sinYaw$1$ = -8						; size = 4
_vecLeft$1$ = -4					; size = 4
_sinPitch$1$ = 8					; size = 4
_yaw$ = 8						; size = 4
_vecView$1$ = 12					; size = 4
_pitch$ = 12						; size = 4
_cameraPos$ = 16					; size = 4
_outWorldToCamera$ = 20					; size = 4
?calcWorldToCamera_FPU@@YAXMMQBMQAY03M@Z PROC		; calcWorldToCamera_FPU, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	movss	xmm0, DWORD PTR _yaw$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 430  :         {return ((float)sin((double)_X)); }

	cvtps2pd xmm0, xmm0
	push	esi
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sinYaw$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _yaw$[ebp]

; 410  :         {return ((float)cos((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cosYaw$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _pitch$[ebp]

; 430  :         {return ((float)sin((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sinPitch$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _pitch$[ebp]

; 410  :         {return ((float)cos((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp

; 43   : 	float vecUp[3] = { -cosYaw * sinPitch, -sinYaw * sinPitch, cosPitch };

	movss	xmm5, DWORD PTR _sinPitch$1$[ebp]
	movss	xmm1, DWORD PTR _sinYaw$1$[ebp]
	xorps	xmm7, xmm7
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 410  :         {return ((float)cos((double)_X)); }

	cvtsd2ss xmm7, xmm0
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp

; 43   : 	float vecUp[3] = { -cosYaw * sinPitch, -sinYaw * sinPitch, cosPitch };

	movaps	xmm4, xmm5
	mulss	xmm4, xmm1
	movaps	xmm2, xmm7
	mulss	xmm2, xmm1
	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000

; 44   : 	float vecLeft[3] =
; 45   : 	{
; 46   : 		vecUp[1]*vecView[2] - vecUp[2]*vecView[1],

	movaps	xmm1, xmm4
	mulss	xmm1, xmm5
	movaps	xmm0, xmm2
	mulss	xmm0, xmm7
	movaps	xmm6, xmm5
	mulss	xmm6, DWORD PTR _cosYaw$1$[ebp]
	subss	xmm1, xmm0
	movaps	xmm3, xmm7
	mulss	xmm3, DWORD PTR _cosYaw$1$[ebp]
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000

; 49   : 	};
; 50   : 
; 51   : 	// Create matrix by assembling vectors as columns
; 52   : 	memset(outWorldToCamera, 0, sizeof(float)*4*4);

	mov	esi, DWORD PTR _outWorldToCamera$[ebp]
	movss	DWORD PTR _vecLeft$1$[ebp], xmm1
	movaps	xmm1, xmm3
	mulss	xmm1, xmm7
	movaps	xmm0, xmm6
	mulss	xmm0, xmm5
	push	64					; 00000040H
	push	0
	subss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm3
	push	esi
	movss	DWORD PTR _vecLeft$2$[ebp], xmm1
	movaps	xmm1, xmm6
	mulss	xmm1, xmm2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 410  :         {return ((float)cos((double)_X)); }

	movss	DWORD PTR _cosPitch$1$[ebp], xmm7
; File c:\source\reed-util\fpu-vs-sse\world-to-camera.cpp

; 42   : 	float vecView[3] = { cosYaw * cosPitch, sinYaw * cosPitch, sinPitch };

	movss	DWORD PTR _vecView$1$[ebp], xmm3

; 47   : 		vecUp[2]*vecView[0] - vecUp[0]*vecView[2],
; 48   : 		vecUp[0]*vecView[1] - vecUp[1]*vecView[0],

	subss	xmm1, xmm0
	movss	DWORD PTR _vecView$2$[ebp], xmm2
	movss	DWORD PTR _vecUp$1$[ebp], xmm6
	movss	DWORD PTR _vecUp$2$[ebp], xmm4
	movss	DWORD PTR _vecLeft$3$[ebp], xmm1

; 49   : 	};
; 50   : 
; 51   : 	// Create matrix by assembling vectors as columns
; 52   : 	memset(outWorldToCamera, 0, sizeof(float)*4*4);

	call	_memset

; 53   : 	outWorldToCamera[0][0] = vecView[0]; outWorldToCamera[1][0] = vecView[1]; outWorldToCamera[2][0] = vecView[2];

	movss	xmm0, DWORD PTR _vecView$1$[ebp]
	movss	xmm1, DWORD PTR _vecView$2$[ebp]

; 54   : 	outWorldToCamera[0][1] = vecLeft[0]; outWorldToCamera[1][1] = vecLeft[1]; outWorldToCamera[2][1] = vecLeft[2];

	movss	xmm7, DWORD PTR _vecLeft$2$[ebp]
	movss	xmm6, DWORD PTR _vecLeft$3$[ebp]

; 55   : 	outWorldToCamera[0][2] = vecUp[0];   outWorldToCamera[1][2] = vecUp[1];   outWorldToCamera[2][2] = vecUp[2];
; 56   : 
; 57   : 	// Calculate inverse translation, -cameraPos * outWorldToCamera
; 58   : 	float invTranslation[] =
; 59   : 	{
; 60   : 		-(cameraPos[0] * outWorldToCamera[0][0] + cameraPos[1] * outWorldToCamera[1][0] + cameraPos[2] * outWorldToCamera[2][0]),

	mov	eax, DWORD PTR _cameraPos$[ebp]
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR _sinPitch$1$[ebp]
	movss	DWORD PTR [esi+32], xmm0
	movss	xmm0, DWORD PTR _vecLeft$1$[ebp]
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR _vecUp$1$[ebp]
	movss	DWORD PTR [esi+8], xmm0
	movss	xmm0, DWORD PTR _vecUp$2$[ebp]
	movss	DWORD PTR [esi+24], xmm0
	movss	xmm0, DWORD PTR _cosPitch$1$[ebp]
	add	esp, 12					; 0000000cH
	movss	DWORD PTR [esi+16], xmm1
	movss	DWORD PTR [esi+20], xmm7
	movss	DWORD PTR [esi+36], xmm6
	movss	DWORD PTR [esi+40], xmm0
	movss	xmm3, DWORD PTR [eax+4]
	movss	xmm5, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [eax+8]
	movaps	xmm4, xmm5
	mulss	xmm4, DWORD PTR _vecView$1$[ebp]
	movaps	xmm0, xmm3
	mulss	xmm0, xmm1

; 61   : 		-(cameraPos[0] * outWorldToCamera[0][1] + cameraPos[1] * outWorldToCamera[1][1] + cameraPos[2] * outWorldToCamera[2][1]),

	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR _vecLeft$1$[ebp]

; 62   : 		-(cameraPos[0] * outWorldToCamera[0][2] + cameraPos[1] * outWorldToCamera[1][2] + cameraPos[2] * outWorldToCamera[2][2]),

	mulss	xmm5, DWORD PTR _vecUp$1$[ebp]
	addss	xmm4, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _sinPitch$1$[ebp]

; 63   : 	};
; 64   : 
; 65   : 	// Stuff it in the matrix, with final component = 1.0
; 66   : 	outWorldToCamera[3][0] = invTranslation[0];
; 67   : 	outWorldToCamera[3][1] = invTranslation[1];
; 68   : 	outWorldToCamera[3][2] = invTranslation[2];
; 69   : 	outWorldToCamera[3][3] = 1.0f;

	mov	DWORD PTR [esi+60], 1065353216		; 3f800000H
	addss	xmm4, xmm0
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR _vecUp$2$[ebp]
	mulss	xmm0, xmm7
	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm5, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm2, DWORD PTR _cosPitch$1$[ebp]
	mulss	xmm0, xmm6
	addss	xmm5, xmm2
	movss	DWORD PTR [esi+48], xmm4
	addss	xmm1, xmm0
	xorps	xmm5, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+56], xmm5
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+52], xmm1
	pop	esi

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?calcWorldToCamera_FPU@@YAXMMQBMQAY03M@Z ENDP		; calcWorldToCamera_FPU
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
tv74 = 8						; size = 4
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 537  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 430  :         {return ((float)sin((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0

; 537  :         {return (sinf(_X)); }

	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
tv74 = 8						; size = 4
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 511  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 410  :         {return ((float)cos((double)_X)); }

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0

; 511  :         {return (cosf(_X)); }

	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv70 = 8						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]
	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
	fld	DWORD PTR tv70[ebp]
	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv70 = 8						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]
	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
	fld	DWORD PTR tv70[ebp]
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
END
