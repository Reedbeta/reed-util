; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Source\reed-util\fpu-vs-sse\transform-aabbs.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
PUBLIC	?transformAABBs_FPU@@YAXHPBUAABB@@QAY133$$CBMPAU1@@Z ; transformAABBs_FPU
PUBLIC	??$min@M@std@@YAABMABM0@Z			; std::min<float>
PUBLIC	??$max@M@std@@YAABMABM0@Z			; std::max<float>
PUBLIC	?transformAABBs_SSE_aos@@YAXHPBUAABB_aos@@QAY03$$CBT__m128@@PAU1@@Z ; transformAABBs_SSE_aos
PUBLIC	?transformAABBs_SSE_soa@@YAXHUAABBs_soa@@Umats_soa@@0@Z ; transformAABBs_SSE_soa
PUBLIC	__real@7f7fffff
PUBLIC	__real@ff7fffff
PUBLIC	__xmm@000000007f7fffff7f7fffff7f7fffff
PUBLIC	__xmm@00000000ff7fffffff7fffffff7fffff
PUBLIC	__xmm@7f7fffff7f7fffff7f7fffff7f7fffff
PUBLIC	__xmm@ff7fffffff7fffffff7fffffff7fffff
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@ff7fffffff7fffffff7fffffff7fffff
CONST	SEGMENT
__xmm@ff7fffffff7fffffff7fffffff7fffff DB 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH
	DB	07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
CONST	ENDS
;	COMDAT __xmm@7f7fffff7f7fffff7f7fffff7f7fffff
CONST	SEGMENT
__xmm@7f7fffff7f7fffff7f7fffff7f7fffff DB 0ffH, 0ffH, 07fH, 07fH, 0ffH, 0ffH
	DB	07fH, 07fH, 0ffH, 0ffH, 07fH, 07fH, 0ffH, 0ffH, 07fH, 07fH
CONST	ENDS
;	COMDAT __xmm@00000000ff7fffffff7fffffff7fffff
CONST	SEGMENT
__xmm@00000000ff7fffffff7fffffff7fffff DB 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH
	DB	07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@000000007f7fffff7f7fffff7f7fffff
CONST	SEGMENT
__xmm@000000007f7fffff7f7fffff7f7fffff DB 0ffH, 0ffH, 07fH, 07fH, 0ffH, 0ffH
	DB	07fH, 07fH, 0ffH, 0ffH, 07fH, 07fH, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+038
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
;	COMDAT ?transformAABBs_SSE_soa@@YAXHUAABBs_soa@@Umats_soa@@0@Z
_TEXT	SEGMENT
_zMinsNew$1$ = -288					; size = 16
_xMaxsNew$1$ = -272					; size = 16
_yMinsNew$1$ = -256					; size = 16
_zMaxsNew$1$ = -240					; size = 16
_inBBs$GSCopy$ = -240					; size = 24
tv942 = -196						; size = 4
_yMaxsNew$1$ = -192					; size = 16
_outBBs$GSCopy$ = -192					; size = 24
tv931 = -156						; size = 4
tv961 = -152						; size = 4
tv946 = -148						; size = 4
tv966 = -144						; size = 4
tv938 = -140						; size = 4
tv929 = -136						; size = 4
tv920 = -132						; size = 4
tv932 = -128						; size = 4
tv921 = -124						; size = 4
tv944 = -120						; size = 4
tv922 = -116						; size = 4
tv950 = -112						; size = 4
tv925 = -108						; size = 4
tv964 = -104						; size = 4
tv926 = -100						; size = 4
tv969 = -96						; size = 4
tv928 = -92						; size = 4
tv930 = -88						; size = 4
tv936 = -84						; size = 4
tv940 = -80						; size = 4
_nSIMD$1$ = -76						; size = 4
_mats$GSCopy$ = -72					; size = 64
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_inBBs$ = 12						; size = 24
_mats$ = 36						; size = 64
_outBBs$ = 100						; size = 24
?transformAABBs_SSE_soa@@YAXHUAABBs_soa@@Umats_soa@@0@Z PROC ; transformAABBs_SSE_soa, COMDAT

; 140  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 141  : 	// Do 4 BBs at a time
; 142  : 	int nSIMD = (n + 3) / 4;

	push	esi
	push	edi
	movq	xmm0, QWORD PTR _inBBs$[ebx]
	mov	eax, DWORD PTR _n$[ebx]
	movq	QWORD PTR _inBBs$GSCopy$[ebp], xmm0
	movq	xmm0, QWORD PTR _inBBs$[ebx+8]
	movq	QWORD PTR _inBBs$GSCopy$[ebp+8], xmm0
	movq	xmm0, QWORD PTR _inBBs$[ebx+16]
	add	eax, 3
	cdq
	movq	QWORD PTR _inBBs$GSCopy$[ebp+16], xmm0
	movq	xmm0, QWORD PTR _outBBs$[ebx]
	and	edx, 3
	movq	QWORD PTR _outBBs$GSCopy$[ebp], xmm0
	movq	xmm0, QWORD PTR _outBBs$[ebx+8]
	add	eax, edx
	sar	eax, 2
	movq	QWORD PTR _outBBs$GSCopy$[ebp+8], xmm0
	movq	xmm0, QWORD PTR _outBBs$[ebx+16]
	mov	ecx, 16					; 00000010H
	lea	esi, DWORD PTR _mats$[ebx]
	lea	edi, DWORD PTR _mats$GSCopy$[ebp]
	rep movsd
	movq	QWORD PTR _outBBs$GSCopy$[ebp+16], xmm0
	mov	DWORD PTR _nSIMD$1$[ebp], eax

; 143  : 	for (int i = 0; i < nSIMD; ++i)

	test	eax, eax
	jle	$LN4@transformA
	mov	ecx, DWORD PTR _mats$GSCopy$[ebp]
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+16]
	sub	eax, ecx
	mov	DWORD PTR tv969[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+32]
	sub	eax, ecx
	mov	DWORD PTR tv966[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+48]
	sub	eax, ecx
	mov	DWORD PTR tv964[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+20]
	sub	eax, ecx
	mov	DWORD PTR tv961[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+4]
	sub	eax, ecx
	mov	DWORD PTR tv950[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+36]
	sub	eax, ecx
	mov	DWORD PTR tv946[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+52]
	sub	eax, ecx
	mov	DWORD PTR tv944[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+24]
	sub	eax, ecx
	mov	DWORD PTR tv942[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+8]
	sub	eax, ecx
	mov	DWORD PTR tv940[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+40]
	sub	eax, ecx
	mov	DWORD PTR tv938[ebp], eax
	mov	eax, DWORD PTR _mats$GSCopy$[ebp+56]
	sub	eax, ecx
	mov	DWORD PTR tv936[ebp], eax
	mov	eax, DWORD PTR _inBBs$GSCopy$[ebp+16]
	sub	eax, ecx
	mov	DWORD PTR tv932[ebp], eax
	mov	eax, DWORD PTR _inBBs$GSCopy$[ebp+4]
	sub	eax, ecx
	mov	DWORD PTR tv931[ebp], eax
	mov	eax, DWORD PTR _inBBs$GSCopy$[ebp+20]
	sub	eax, ecx
	mov	DWORD PTR tv930[ebp], eax
	mov	eax, DWORD PTR _inBBs$GSCopy$[ebp+8]
	sub	eax, ecx
	mov	DWORD PTR tv929[ebp], eax
	mov	eax, DWORD PTR _outBBs$GSCopy$[ebp]
	mov	esi, DWORD PTR _inBBs$GSCopy$[ebp+12]
	mov	edi, DWORD PTR _inBBs$GSCopy$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv928[ebp], eax
	mov	eax, DWORD PTR _outBBs$GSCopy$[ebp+4]
	sub	eax, ecx
	mov	DWORD PTR tv926[ebp], eax
	mov	eax, DWORD PTR _outBBs$GSCopy$[ebp+8]
	sub	eax, ecx
	mov	DWORD PTR tv925[ebp], eax
	mov	eax, DWORD PTR _outBBs$GSCopy$[ebp+12]
	sub	eax, ecx
	mov	DWORD PTR tv922[ebp], eax
	mov	eax, DWORD PTR _outBBs$GSCopy$[ebp+16]
	sub	eax, ecx
	mov	DWORD PTR tv921[ebp], eax
	mov	eax, DWORD PTR _outBBs$GSCopy$[ebp+20]
	sub	esi, ecx
	sub	edi, ecx
	sub	eax, ecx
	mov	DWORD PTR tv920[ebp], eax
	npad	2
$LL6@transformA:

; 144  : 	{
; 145  : 		__m128 xMinsNew = { FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX };
; 146  : 		__m128 yMinsNew = { FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX };
; 147  : 		__m128 zMinsNew = { FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX };
; 148  : 		__m128 xMaxsNew = { -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX };
; 149  : 		__m128 yMaxsNew = { -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX };
; 150  : 		__m128 zMaxsNew = { -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX };
; 151  : 
; 152  : 		for (int j = 0; j < 8; ++j)

	movaps	xmm0, XMMWORD PTR __xmm@7f7fffff7f7fffff7f7fffff7f7fffff
	movaps	xmm7, XMMWORD PTR __xmm@7f7fffff7f7fffff7f7fffff7f7fffff
	movaps	XMMWORD PTR _yMinsNew$1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@7f7fffff7f7fffff7f7fffff7f7fffff
	movaps	XMMWORD PTR _zMinsNew$1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffffff7fffffff7fffff
	movaps	XMMWORD PTR _xMaxsNew$1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffffff7fffffff7fffff
	movaps	XMMWORD PTR _yMaxsNew$1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffffff7fffffff7fffff
	movaps	XMMWORD PTR _zMaxsNew$1$[ebp], xmm0
	xor	edx, edx
	npad	1
$LL3@transformA:

; 153  : 		{
; 154  : 			__m128 xsCorner = ((j & 1) != 0) ? inBBs.xMaxs[i] : inBBs.xMins[i];

	lea	eax, DWORD PTR [esi+ecx]
	test	dl, 1
	jne	SHORT $LN10@transformA
	lea	eax, DWORD PTR [edi+ecx]
$LN10@transformA:
	movaps	xmm6, XMMWORD PTR [eax]

; 155  : 			__m128 ysCorner = ((j & 2) != 0) ? inBBs.yMaxs[i] : inBBs.yMins[i];

	mov	eax, DWORD PTR tv932[ebp]
	test	dl, 2
	jne	SHORT $LN21@transformA
	mov	eax, DWORD PTR tv931[ebp]
$LN21@transformA:
	movaps	xmm5, XMMWORD PTR [eax+ecx]
	add	eax, ecx

; 156  : 			__m128 zsCorner = ((j & 4) != 0) ? inBBs.zMaxs[i] : inBBs.zMins[i];

	mov	eax, DWORD PTR tv930[ebp]
	test	dl, 4
	jne	SHORT $LN22@transformA
	mov	eax, DWORD PTR tv929[ebp]
$LN22@transformA:
	movaps	xmm2, XMMWORD PTR [eax+ecx]

; 157  : 
; 158  : 			__m128 xsCornerTransformed = _mm_add_ps(
; 159  : 											_mm_add_ps(_mm_mul_ps(xsCorner, mats.comps[0][0][i]),
; 160  : 													   _mm_mul_ps(ysCorner, mats.comps[1][0][i])),
; 161  : 											_mm_add_ps(_mm_mul_ps(zsCorner, mats.comps[2][0][i]),
; 162  : 																			mats.comps[3][0][i]));

	movaps	xmm0, XMMWORD PTR [ecx]
	add	eax, ecx
	mov	eax, DWORD PTR tv969[ebp]
	mulps	xmm0, xmm6
	movaps	xmm4, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv966[ebp]
	mulps	xmm4, xmm5
	inc	edx
	addps	xmm4, xmm0
	movaps	xmm0, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv964[ebp]
	mulps	xmm0, xmm2
	addps	xmm0, XMMWORD PTR [eax+ecx]

; 163  : 			__m128 ysCornerTransformed = _mm_add_ps(
; 164  : 											_mm_add_ps(_mm_mul_ps(xsCorner, mats.comps[0][1][i]),
; 165  : 													   _mm_mul_ps(ysCorner, mats.comps[1][1][i])),
; 166  : 											_mm_add_ps(_mm_mul_ps(zsCorner, mats.comps[2][1][i]),
; 167  : 																			mats.comps[3][1][i]));

	mov	eax, DWORD PTR tv961[ebp]
	movaps	xmm3, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv950[ebp]
	addps	xmm4, xmm0
	movaps	xmm0, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv946[ebp]
	mulps	xmm0, xmm6
	mulps	xmm3, xmm5

; 168  : 			__m128 zsCornerTransformed = _mm_add_ps(
; 169  : 											_mm_add_ps(_mm_mul_ps(xsCorner, mats.comps[0][2][i]),
; 170  : 													   _mm_mul_ps(ysCorner, mats.comps[1][2][i])),
; 171  : 											_mm_add_ps(_mm_mul_ps(zsCorner, mats.comps[2][2][i]),
; 172  : 																			mats.comps[3][2][i]));
; 173  : 
; 174  : 			xMinsNew = _mm_min_ps(xMinsNew, xsCornerTransformed);

	minps	xmm7, xmm4
	addps	xmm3, xmm0
	movaps	xmm0, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv944[ebp]
	mulps	xmm0, xmm2
	addps	xmm0, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv942[ebp]
	movaps	xmm1, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv940[ebp]
	addps	xmm3, xmm0
	movaps	xmm0, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv938[ebp]
	mulps	xmm0, xmm6
	mulps	xmm1, xmm5

; 175  : 			yMinsNew = _mm_min_ps(yMinsNew, ysCornerTransformed);
; 176  : 			zMinsNew = _mm_min_ps(zMinsNew, zsCornerTransformed);
; 177  : 			xMaxsNew = _mm_max_ps(xMaxsNew, xsCornerTransformed);

	movaps	xmm5, XMMWORD PTR _xMaxsNew$1$[ebp]
	maxps	xmm5, xmm4

; 178  : 			yMaxsNew = _mm_max_ps(yMaxsNew, ysCornerTransformed);

	movaps	xmm4, XMMWORD PTR _yMaxsNew$1$[ebp]
	addps	xmm1, xmm0
	movaps	xmm0, XMMWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv936[ebp]
	mulps	xmm0, xmm2
	movaps	xmm2, XMMWORD PTR _zMinsNew$1$[ebp]
	maxps	xmm4, xmm3
	addps	xmm0, XMMWORD PTR [eax+ecx]
	movaps	XMMWORD PTR _xMaxsNew$1$[ebp], xmm5
	movaps	XMMWORD PTR _yMaxsNew$1$[ebp], xmm4
	addps	xmm1, xmm0
	movaps	xmm0, XMMWORD PTR _yMinsNew$1$[ebp]
	minps	xmm0, xmm3

; 179  : 			zMaxsNew = _mm_max_ps(zMaxsNew, zsCornerTransformed);

	movaps	xmm3, XMMWORD PTR _zMaxsNew$1$[ebp]
	minps	xmm2, xmm1
	maxps	xmm3, xmm1
	movaps	XMMWORD PTR _yMinsNew$1$[ebp], xmm0
	movaps	XMMWORD PTR _zMinsNew$1$[ebp], xmm2
	movaps	XMMWORD PTR _zMaxsNew$1$[ebp], xmm3
	cmp	edx, 8
	jl	$LL3@transformA

; 180  : 		}
; 181  : 
; 182  : 		outBBs.xMins[i] = xMinsNew;

	mov	eax, DWORD PTR tv928[ebp]
	add	ecx, 16					; 00000010H
	dec	DWORD PTR _nSIMD$1$[ebp]
	movaps	XMMWORD PTR [eax+ecx-16], xmm7

; 183  : 		outBBs.yMins[i] = yMinsNew;

	mov	eax, DWORD PTR tv926[ebp]
	movaps	XMMWORD PTR [eax+ecx-16], xmm0

; 184  : 		outBBs.zMins[i] = zMinsNew;

	mov	eax, DWORD PTR tv925[ebp]
	movaps	XMMWORD PTR [eax+ecx-16], xmm2

; 185  : 		outBBs.xMaxs[i] = xMaxsNew;

	mov	eax, DWORD PTR tv922[ebp]
	movaps	XMMWORD PTR [eax+ecx-16], xmm5

; 186  : 		outBBs.yMaxs[i] = yMaxsNew;

	mov	eax, DWORD PTR tv921[ebp]
	movaps	XMMWORD PTR [eax+ecx-16], xmm4

; 187  : 		outBBs.zMaxs[i] = zMaxsNew;

	mov	eax, DWORD PTR tv920[ebp]
	movaps	XMMWORD PTR [eax+ecx-16], xmm3
	jne	$LL6@transformA
$LN4@transformA:

; 188  : 	}
; 189  : 
; 190  : 	(void)mats;
; 191  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?transformAABBs_SSE_soa@@YAXHUAABBs_soa@@Umats_soa@@0@Z ENDP ; transformAABBs_SSE_soa
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
;	COMDAT ?transformAABBs_SSE_aos@@YAXHPBUAABB_aos@@QAY03$$CBT__m128@@PAU1@@Z
_TEXT	SEGMENT
_corner$1 = -16						; size = 16
_n$ = 8							; size = 4
_inBBs$ = 12						; size = 4
_mats$ = 16						; size = 4
_outBBs$ = 20						; size = 4
?transformAABBs_SSE_aos@@YAXHPBUAABB_aos@@QAY03$$CBT__m128@@PAU1@@Z PROC ; transformAABBs_SSE_aos, COMDAT

; 82   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi

; 83   : 	for (int i = 0; i < n; ++i)

	mov	edi, DWORD PTR _n$[ebx]
	test	edi, edi
	jle	$LN4@transformA
	mov	edx, DWORD PTR _mats$[ebx]
	mov	eax, DWORD PTR _inBBs$[ebx]
	mov	esi, DWORD PTR _outBBs$[ebx]
	add	edx, 32					; 00000020H
	add	eax, 20					; 00000014H
	npad	11
$LL6@transformA:

; 84   : 	{
; 85   : 		__m128 newMins = { FLT_MAX, FLT_MAX, FLT_MAX };
; 86   : 		__m128 newMaxs = { -FLT_MAX, -FLT_MAX, -FLT_MAX };
; 87   : 		// Note: constructing the corners can be done more efficiently with shuffles,
; 88   : 		// but in a typical vector math lib, this is what you're likely to get
; 89   : 		for (int j = 0; j < 8; ++j)

	movaps	xmm3, XMMWORD PTR __xmm@000000007f7fffff7f7fffff7f7fffff
	movaps	xmm4, XMMWORD PTR __xmm@00000000ff7fffffff7fffffff7fffff
	movaps	xmm5, XMMWORD PTR [edx-32]
	movaps	xmm6, XMMWORD PTR [edx-16]
	movaps	xmm7, XMMWORD PTR [edx]
	xor	ecx, ecx
	npad	5
$LL3@transformA:

; 90   : 		{
; 91   : 			__m128 corner =
; 92   : 			{
; 93   : 				((j & 1) != 0) ? inBBs[i].maxs.m128_f32[0] : inBBs[i].mins.m128_f32[0],

	test	cl, 1
	je	SHORT $LN9@transformA
	movss	xmm0, DWORD PTR [eax-4]
	jmp	SHORT $LN21@transformA
$LN9@transformA:
	movss	xmm0, DWORD PTR [eax-20]
$LN21@transformA:
	movss	DWORD PTR _corner$1[ebp], xmm0

; 94   : 				((j & 2) != 0) ? inBBs[i].maxs.m128_f32[1] : inBBs[i].mins.m128_f32[1],

	test	cl, 2
	je	SHORT $LN11@transformA
	movss	xmm0, DWORD PTR [eax]
	jmp	SHORT $LN22@transformA
$LN11@transformA:
	movss	xmm0, DWORD PTR [eax-16]
$LN22@transformA:
	movss	DWORD PTR _corner$1[ebp+4], xmm0

; 95   : 				((j & 4) != 0) ? inBBs[i].maxs.m128_f32[2] : inBBs[i].mins.m128_f32[2],

	test	cl, 4
	je	SHORT $LN13@transformA
	movss	xmm0, DWORD PTR [eax+4]
	jmp	SHORT $LN23@transformA
$LN13@transformA:
	movss	xmm0, DWORD PTR [eax-12]
$LN23@transformA:
	movss	DWORD PTR _corner$1[ebp+8], xmm0

; 96   : 			};

	mov	DWORD PTR _corner$1[ebp+12], 0

; 97   : 			// Multiply by matrix
; 98   : 			__m128 cornerX = _mm_shuffle_ps(corner, corner, _MM_SHUFFLE(0,0,0,0));

	movaps	xmm1, XMMWORD PTR _corner$1[ebp]
	movaps	xmm2, xmm1
	shufps	xmm2, xmm1, 0

; 99   : 			__m128 cornerY = _mm_shuffle_ps(corner, corner, _MM_SHUFFLE(1,1,1,1));
; 100  : 			__m128 cornerZ = _mm_shuffle_ps(corner, corner, _MM_SHUFFLE(2,2,2,2));
; 101  : 			__m128 cornerTransformed = _mm_setzero_ps();
; 102  : 			cornerTransformed = _mm_add_ps(cornerTransformed, _mm_mul_ps(cornerX, mats[i][0]));

	mulps	xmm2, xmm5
	xorps	xmm0, xmm0
	inc	ecx
	addps	xmm2, xmm0
	movaps	xmm0, xmm1
	shufps	xmm0, xmm1, 85				; 00000055H

; 103  : 			cornerTransformed = _mm_add_ps(cornerTransformed, _mm_mul_ps(cornerY, mats[i][1]));

	mulps	xmm0, xmm6
	shufps	xmm1, xmm1, 170				; 000000aaH

; 104  : 			cornerTransformed = _mm_add_ps(cornerTransformed, _mm_mul_ps(cornerZ, mats[i][2]));

	mulps	xmm1, xmm7
	addps	xmm2, xmm0
	addps	xmm2, xmm1

; 105  : 			cornerTransformed = _mm_add_ps(cornerTransformed, mats[i][3]);

	addps	xmm2, XMMWORD PTR [edx+16]

; 106  : 			newMins = _mm_min_ps(newMins, cornerTransformed);

	minps	xmm3, xmm2

; 107  : 			newMaxs = _mm_max_ps(newMaxs, cornerTransformed);

	maxps	xmm4, xmm2
	cmp	ecx, 8
	jl	$LL3@transformA

; 108  : 		}
; 109  : 		outBBs[i].mins = newMins;

	movaps	XMMWORD PTR [esi], xmm3

; 110  : 		outBBs[i].maxs = newMaxs;

	movaps	XMMWORD PTR [esi+16], xmm4
	add	edx, 64					; 00000040H
	add	eax, 32					; 00000020H
	add	esi, 32					; 00000020H
	dec	edi
	jne	$LL6@transformA
$LN4@transformA:

; 111  : 
; 112  : 		// Here's an implementation with shuffles, for reference,
; 113  : 		// which is a great deal faster than the non-shuffle version
; 114  : 		// (but not as fast as SOA).
; 115  : /*
; 116  : 		// shuffle (xyzw, XYZW) to (xyXY, zwZW)
; 117  : 		__m128 xyXY = _mm_shuffle_ps(inBBs[i].mins, inBBs[i].maxs, _MM_SHUFFLE(1,0,1,0));
; 118  : 		__m128 zwZW = _mm_shuffle_ps(inBBs[i].mins, inBBs[i].maxs, _MM_SHUFFLE(3,2,3,2));
; 119  : 		// thence shuffle to (xyzw, Xyzw, xYzw, XYzw, xyZw, XyZw, xYZw, XYZw)
; 120  : 		__m128 corner[] = 
; 121  : 		{
; 122  : 			_mm_shuffle_ps(xyXY, zwZW, _MM_SHUFFLE(1,0,1,0)),
; 123  : 			_mm_shuffle_ps(xyXY, zwZW, _MM_SHUFFLE(1,0,1,2)),
; 124  : 			_mm_shuffle_ps(xyXY, zwZW, _MM_SHUFFLE(1,0,3,0)),
; 125  : 			_mm_shuffle_ps(xyXY, zwZW, _MM_SHUFFLE(1,0,3,2)),
; 126  : 			_mm_shuffle_ps(xyXY, zwZW, _MM_SHUFFLE(1,2,1,0)),
; 127  : 			_mm_shuffle_ps(xyXY, zwZW, _MM_SHUFFLE(1,2,1,2)),
; 128  : 			_mm_shuffle_ps(xyXY, zwZW, _MM_SHUFFLE(1,2,3,0)),
; 129  : 			_mm_shuffle_ps(xyXY, zwZW, _MM_SHUFFLE(1,2,3,2)),
; 130  : 		};
; 131  : */
; 132  : 	}
; 133  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?transformAABBs_SSE_aos@@YAXHPBUAABB_aos@@QAY03$$CBT__m128@@PAU1@@Z ENDP ; transformAABBs_SSE_aos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$max@M@std@@YAABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@M@std@@YAABMABM0@Z PROC				; std::max<float>, COMDAT

; 2031 : 	{	// return larger of _Left and _Right

	push	ebp
	mov	ebp, esp

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, DWORD PTR [eax]
	cmova	eax, ecx

; 2033 : 	}

	pop	ebp
	ret	0
??$max@M@std@@YAABMABM0@Z ENDP				; std::max<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$min@M@std@@YAABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@M@std@@YAABMABM0@Z PROC				; std::min<float>, COMDAT

; 2049 : 	{	// return smaller of _Left and _Right

	push	ebp
	mov	ebp, esp

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR [ecx]
	cmova	eax, ecx

; 2051 : 	}

	pop	ebp
	ret	0
??$min@M@std@@YAABMABM0@Z ENDP				; std::min<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp
;	COMDAT ?transformAABBs_FPU@@YAXHPBUAABB@@QAY133$$CBMPAU1@@Z
_TEXT	SEGMENT
_outBBs$GSCopy$1$ = -44					; size = 4
_cornerTransformed$1 = -40				; size = 12
_newMins$2 = -28					; size = 12
_newMaxs$3 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_inBBs$ = 12						; size = 4
_mats$ = 16						; size = 4
_outBBs$ = 20						; size = 4
?transformAABBs_FPU@@YAXHPBUAABB@@QAY133$$CBMPAU1@@Z PROC ; transformAABBs_FPU, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, DWORD PTR _outBBs$[ebp]
	push	ebx

; 44   : 	for (int i = 0; i < n; ++i)

	mov	ebx, DWORD PTR _n$[ebp]
	test	ebx, ebx
	jle	$LN4@transformA
	mov	eax, DWORD PTR _inBBs$[ebp]
	push	esi
	mov	esi, DWORD PTR _mats$[ebp]
	push	edi
	lea	edi, DWORD PTR [edx+8]
	add	esi, 32					; 00000020H
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _outBBs$GSCopy$1$[ebp], edx
	npad	11
$LL6@transformA:

; 45   : 	{
; 46   : 		float newMins[] = { FLT_MAX, FLT_MAX, FLT_MAX };

	movss	xmm0, DWORD PTR __real@7f7fffff
	movaps	xmm7, xmm0
	movss	DWORD PTR _newMins$2[ebp+4], xmm0
	movss	DWORD PTR _newMins$2[ebp+8], xmm0

; 47   : 		float newMaxs[] = { -FLT_MAX, -FLT_MAX, -FLT_MAX };

	movss	xmm0, DWORD PTR __real@ff7fffff
	movss	DWORD PTR _newMins$2[ebp], xmm7
	movss	DWORD PTR _newMaxs$3[ebp], xmm0
	movss	DWORD PTR _newMaxs$3[ebp+4], xmm0
	movss	DWORD PTR _newMaxs$3[ebp+8], xmm0

; 48   : 		for (int j = 0; j < 8; ++j)

	xor	edx, edx
$LL3@transformA:

; 49   : 		{
; 50   : 			float corner[] =
; 51   : 			{
; 52   : 				((j & 1) != 0) ? inBBs[i].maxs[0] : inBBs[i].mins[0],

	test	dl, 1
	je	SHORT $LN9@transformA
	movss	xmm6, DWORD PTR [ecx-4]
	jmp	SHORT $LN10@transformA
$LN9@transformA:
	movss	xmm6, DWORD PTR [ecx-16]
$LN10@transformA:

; 53   : 				((j & 2) != 0) ? inBBs[i].maxs[1] : inBBs[i].mins[1],

	test	dl, 2
	je	SHORT $LN11@transformA
	movss	xmm5, DWORD PTR [ecx]
	jmp	SHORT $LN12@transformA
$LN11@transformA:
	movss	xmm5, DWORD PTR [ecx-12]
$LN12@transformA:

; 54   : 				((j & 4) != 0) ? inBBs[i].maxs[2] : inBBs[i].mins[2],

	test	dl, 4
	je	SHORT $LN13@transformA
	movss	xmm4, DWORD PTR [ecx+4]
	jmp	SHORT $LN14@transformA
$LN13@transformA:
	movss	xmm4, DWORD PTR [ecx-8]
$LN14@transformA:

; 58   : 				corner[0] * mats[i][0][0] + corner[1] * mats[i][1][0] + corner[2] * mats[i][2][0] + mats[i][3][0],

	movss	xmm3, DWORD PTR [esi-32]
	movss	xmm0, DWORD PTR [esi-16]

; 59   : 				corner[0] * mats[i][0][1] + corner[1] * mats[i][1][1] + corner[2] * mats[i][2][1] + mats[i][3][1],

	movss	xmm2, DWORD PTR [esi-28]
	mulss	xmm0, xmm5
	mulss	xmm3, xmm6

; 60   : 				corner[0] * mats[i][0][2] + corner[1] * mats[i][1][2] + corner[2] * mats[i][2][2] + mats[i][3][2],

	movss	xmm1, DWORD PTR [esi-24]
	mulss	xmm2, xmm6
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [esi]
	mulss	xmm0, xmm4
	mulss	xmm1, xmm6
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [esi-12]
	mulss	xmm0, xmm5
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ebx, DWORD PTR _newMins$2[ebp]
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 58   : 				corner[0] * mats[i][0][0] + corner[1] * mats[i][1][0] + corner[2] * mats[i][2][0] + mats[i][3][0],

	addss	xmm3, DWORD PTR [esi+16]

; 59   : 				corner[0] * mats[i][0][1] + corner[1] * mats[i][1][1] + corner[2] * mats[i][2][1] + mats[i][3][1],

	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [esi+4]
	mulss	xmm0, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	comiss	xmm7, xmm3
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 59   : 				corner[0] * mats[i][0][1] + corner[1] * mats[i][1][1] + corner[2] * mats[i][2][1] + mats[i][3][1],

	addss	xmm2, xmm0

; 60   : 				corner[0] * mats[i][0][2] + corner[1] * mats[i][1][2] + corner[2] * mats[i][2][2] + mats[i][3][2],

	movss	xmm0, DWORD PTR [esi-8]
	mulss	xmm0, xmm5
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR _cornerTransformed$1[ebp]
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 59   : 				corner[0] * mats[i][0][1] + corner[1] * mats[i][1][1] + corner[2] * mats[i][2][1] + mats[i][3][1],

	addss	xmm2, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovbe	eax, ebx
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 60   : 				corner[0] * mats[i][0][2] + corner[1] * mats[i][1][2] + corner[2] * mats[i][2][2] + mats[i][3][2],

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [esi+8]
	mulss	xmm0, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movss	xmm4, DWORD PTR _newMins$2[ebp+8]
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 58   : 				corner[0] * mats[i][0][0] + corner[1] * mats[i][1][0] + corner[2] * mats[i][2][0] + mats[i][3][0],

	movss	DWORD PTR _cornerTransformed$1[ebp], xmm3

; 60   : 				corner[0] * mats[i][0][2] + corner[1] * mats[i][1][2] + corner[2] * mats[i][2][2] + mats[i][3][2],

	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movss	xmm0, DWORD PTR _newMins$2[ebp+4]
	comiss	xmm0, xmm2
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 60   : 				corner[0] * mats[i][0][2] + corner[1] * mats[i][1][2] + corner[2] * mats[i][2][2] + mats[i][3][2],

	addss	xmm1, DWORD PTR [esi+24]
	movss	DWORD PTR _cornerTransformed$1[ebp+4], xmm2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ebx, DWORD PTR _newMins$2[ebp+4]
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 60   : 				corner[0] * mats[i][0][2] + corner[1] * mats[i][1][2] + corner[2] * mats[i][2][2] + mats[i][3][2],

	movss	DWORD PTR _cornerTransformed$1[ebp+8], xmm1

; 62   : 			newMins[0] = min(newMins[0], cornerTransformed[0]);

	movss	xmm7, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR _cornerTransformed$1[ebp+4]
	cmovbe	eax, ebx
	comiss	xmm4, xmm1
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 62   : 			newMins[0] = min(newMins[0], cornerTransformed[0]);

	movss	DWORD PTR _newMins$2[ebp], xmm7

; 63   : 			newMins[1] = min(newMins[1], cornerTransformed[1]);

	movss	xmm0, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2050 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ebx, DWORD PTR _newMins$2[ebp+8]
	lea	eax, DWORD PTR _cornerTransformed$1[ebp+8]
	cmovbe	eax, ebx

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm3, DWORD PTR _newMaxs$3[ebp]
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 63   : 			newMins[1] = min(newMins[1], cornerTransformed[1]);

	movss	DWORD PTR _newMins$2[ebp+4], xmm0

; 64   : 			newMins[2] = min(newMins[2], cornerTransformed[2]);

	movss	xmm4, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	ebx, DWORD PTR _newMaxs$3[ebp]
	lea	eax, DWORD PTR _cornerTransformed$1[ebp]
	cmovbe	eax, ebx
	comiss	xmm2, DWORD PTR _newMaxs$3[ebp+4]
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 65   : 			newMaxs[0] = max(newMaxs[0], cornerTransformed[0]);

	movss	xmm3, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	ebx, DWORD PTR _newMaxs$3[ebp+4]
	lea	eax, DWORD PTR _cornerTransformed$1[ebp+4]
	cmovbe	eax, ebx
	comiss	xmm1, DWORD PTR _newMaxs$3[ebp+8]
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 65   : 			newMaxs[0] = max(newMaxs[0], cornerTransformed[0]);

	movss	DWORD PTR _newMaxs$3[ebp], xmm3

; 66   : 			newMaxs[1] = max(newMaxs[1], cornerTransformed[1]);

	movss	xmm2, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR _cornerTransformed$1[ebp+8]
	lea	ebx, DWORD PTR _newMaxs$3[ebp+8]
	cmovbe	eax, ebx
; File c:\source\reed-util\fpu-vs-sse\transform-aabbs.cpp

; 66   : 			newMaxs[1] = max(newMaxs[1], cornerTransformed[1]);

	movss	DWORD PTR _newMaxs$3[ebp+4], xmm2

; 67   : 			newMaxs[2] = max(newMaxs[2], cornerTransformed[2]);

	movss	xmm1, DWORD PTR [eax]
	inc	edx
	movss	DWORD PTR _newMins$2[ebp+8], xmm4
	movss	DWORD PTR _newMaxs$3[ebp+8], xmm1
	cmp	edx, 8
	jl	$LL3@transformA

; 68   : 		}
; 69   : 		outBBs[i].mins[0] = newMins[0];
; 70   : 		outBBs[i].mins[1] = newMins[1];
; 71   : 		outBBs[i].mins[2] = newMins[2];
; 72   : 		outBBs[i].maxs[0] = newMaxs[0];
; 73   : 		outBBs[i].maxs[1] = newMaxs[1];

	mov	eax, DWORD PTR _outBBs$GSCopy$1$[ebp]
	movss	DWORD PTR [edi-8], xmm7
	movss	DWORD PTR [edi-4], xmm0
	movss	DWORD PTR [edi], xmm4
	movss	DWORD PTR [edi+4], xmm3
	movss	DWORD PTR [eax+ecx], xmm2

; 74   : 		outBBs[i].maxs[2] = newMaxs[2];

	movss	DWORD PTR [edi+12], xmm1
	add	esi, 64					; 00000040H
	add	ecx, 24					; 00000018H
	add	edi, 24					; 00000018H
	dec	DWORD PTR _n$[ebp]
	jne	$LL6@transformA
	pop	edi
	pop	esi
$LN4@transformA:

; 75   : 	}
; 76   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?transformAABBs_FPU@@YAXHPBUAABB@@QAY133$$CBMPAU1@@Z ENDP ; transformAABBs_FPU
_TEXT	ENDS
END
