; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?value@?$integral_constant@_K$0A@@std@@2_KB	; std::integral_constant<unsigned __int64,0>::value
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000000H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_K$0A@@std@@2_KB
CONST	SEGMENT
?value@?$integral_constant@_K$0A@@std@@2_KB DQ 0000000000000000H ; std::integral_constant<unsigned __int64,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2_KB DQ 0000000000000001H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
PUBLIC	fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	??0CTimer@@QEAA@XZ				; CTimer::CTimer
PUBLIC	??1CTimer@@QEAA@XZ				; CTimer::~CTimer
PUBLIC	?seed@RNG@@QEAAXI@Z				; RNG::seed
PUBLIC	?randUint@RNG@@QEAAIXZ				; RNG::randUint
PUBLIC	?randFloat@RNG@@QEAAMXZ				; RNG::randFloat
PUBLIC	?randFloat@RNG@@QEAAMMM@Z			; RNG::randFloat
PUBLIC	main
PUBLIC	??$max@M@std@@YAAEBMAEBM0@Z			; std::max<float>
PUBLIC	??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@		; `string'
PUBLIC	??_C@_0CC@MHCKIHIN@calcWorldToCamera_FPU?5?$CFdM?5times?3@ ; `string'
PUBLIC	??_C@_0CG@LJFHOHJE@calcWorldToCamera_SSE_aos?5?$CFdM?5ti@ ; `string'
PUBLIC	??_C@_0DF@HEJBLKKF@Warning?3?5significant?5mismatch?5in@ ; `string'
PUBLIC	??_C@_0CL@PDOPMEAA@transformAABBs_FPU?0?5?$CFdK?5AABBs?0?5?$CF@ ; `string'
PUBLIC	??_C@_0CP@GOAMJCGE@transformAABBs_SSE_aos?0?5?$CFdK?5AABB@ ; `string'
PUBLIC	??_C@_0CP@MJCAKJJJ@transformAABBs_SSE_soa?0?5?$CFdK?5AABB@ ; `string'
PUBLIC	??_C@_0DG@FAFHICNP@Warning?3?5significant?5mismatch?5in@ ; `string'
PUBLIC	??_C@_0DG@JIIBKMLF@Warning?3?5significant?5mismatch?5in@ ; `string'
PUBLIC	__real@2f800000
PUBLIC	__real@3727c5ac
PUBLIC	__real@3ef0a3d7
PUBLIC	__real@3f3d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40c00000
PUBLIC	__real@40c90fd0
PUBLIC	__real@41100000
PUBLIC	__real@41a00000
PUBLIC	__real@447a0000
PUBLIC	__real@c0400000
PUBLIC	__real@c1200000
PUBLIC	__xmm@0000000040400000400000003f800000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__imp_printf:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	?calcWorldToCamera_FPU@@YAXMMQEBMQEAY03M@Z:PROC	; calcWorldToCamera_FPU
EXTRN	?calcWorldToCamera_SSE_aos@@YAXMMAEBT__m128@@QEAT1@@Z:PROC ; calcWorldToCamera_SSE_aos
EXTRN	?transformAABBs_FPU@@YAXHPEBUAABB@@QEAY133$$CBMPEAU1@@Z:PROC ; transformAABBs_FPU
EXTRN	?transformAABBs_SSE_aos@@YAXHPEBUAABB_aos@@QEAY03$$CBT__m128@@PEAU1@@Z:PROC ; transformAABBs_SSE_aos
EXTRN	?transformAABBs_SSE_soa@@YAXHUAABBs_soa@@Umats_soa@@0@Z:PROC ; transformAABBs_SSE_soa
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
piecewise_construct DB 01H DUP (?)
allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CTimer@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??0CTimer@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CTimer@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$??1CTimer@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN321
	DD	imagerel $LN321+3738
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@0000000040400000400000003f800000
CONST	SEGMENT
__xmm@0000000040400000400000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	'@', 00H, 00H, '@@', 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c0400000
CONST	SEGMENT
__real@c0400000 DD 0c0400000r			; -3
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@40c90fd0
CONST	SEGMENT
__real@40c90fd0 DD 040c90fd0r			; 6.28318
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f3d70a4
CONST	SEGMENT
__real@3f3d70a4 DD 03f3d70a4r			; 0.74
CONST	ENDS
;	COMDAT __real@3ef0a3d7
CONST	SEGMENT
__real@3ef0a3d7 DD 03ef0a3d7r			; 0.47
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@2f800000
CONST	SEGMENT
__real@2f800000 DD 02f800000r			; 2.32831e-010
CONST	ENDS
;	COMDAT ??_C@_0DG@JIIBKMLF@Warning?3?5significant?5mismatch?5in@
CONST	SEGMENT
??_C@_0DG@JIIBKMLF@Warning?3?5significant?5mismatch?5in@ DB 'Warning: sig'
	DB	'nificant mismatch in SOA bounding box %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FAFHICNP@Warning?3?5significant?5mismatch?5in@
CONST	SEGMENT
??_C@_0DG@FAFHICNP@Warning?3?5significant?5mismatch?5in@ DB 'Warning: sig'
	DB	'nificant mismatch in AOS bounding box %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MJCAKJJJ@transformAABBs_SSE_soa?0?5?$CFdK?5AABB@
CONST	SEGMENT
??_C@_0CP@MJCAKJJJ@transformAABBs_SSE_soa?0?5?$CFdK?5AABB@ DB 'transformA'
	DB	'ABBs_SSE_soa, %dK AABBs, %dK times: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GOAMJCGE@transformAABBs_SSE_aos?0?5?$CFdK?5AABB@
CONST	SEGMENT
??_C@_0CP@GOAMJCGE@transformAABBs_SSE_aos?0?5?$CFdK?5AABB@ DB 'transformA'
	DB	'ABBs_SSE_aos, %dK AABBs, %dK times: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PDOPMEAA@transformAABBs_FPU?0?5?$CFdK?5AABBs?0?5?$CF@
CONST	SEGMENT
??_C@_0CL@PDOPMEAA@transformAABBs_FPU?0?5?$CFdK?5AABBs?0?5?$CF@ DB 'trans'
	DB	'formAABBs_FPU, %dK AABBs, %dK times: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HEJBLKKF@Warning?3?5significant?5mismatch?5in@
CONST	SEGMENT
??_C@_0DF@HEJBLKKF@Warning?3?5significant?5mismatch?5in@ DB 'Warning: sig'
	DB	'nificant mismatch in component [%d][%d]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LJFHOHJE@calcWorldToCamera_SSE_aos?5?$CFdM?5ti@
CONST	SEGMENT
??_C@_0CG@LJFHOHJE@calcWorldToCamera_SSE_aos?5?$CFdM?5ti@ DB 'calcWorldTo'
	DB	'Camera_SSE_aos %dM times: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MHCKIHIN@calcWorldToCamera_FPU?5?$CFdM?5times?3@
CONST	SEGMENT
??_C@_0CC@MHCKIHIN@calcWorldToCamera_FPU?5?$CFdM?5times?3@ DB 'calcWorldT'
	DB	'oCamera_FPU %dM times: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
CONST	SEGMENT
??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@ DB '%0.1f ms', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DD imagerel main
	DD	0ffffffffH
	DD	imagerel main+268
	DD	00H
	DD	imagerel main+335
	DD	0ffffffffH
	DD	imagerel main+464
	DD	01H
	DD	imagerel main+492
	DD	0ffffffffH
	DD	imagerel main+1988
	DD	02H
	DD	imagerel main+2036
	DD	0ffffffffH
	DD	imagerel main+2148
	DD	03H
	DD	imagerel main+2196
	DD	0ffffffffH
	DD	imagerel main+2308
	DD	04H
	DD	imagerel main+2607
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DD 0ffffffffH
	DD	imagerel main$dtor$0
	DD	0ffffffffH
	DD	imagerel main$dtor$1
	DD	0ffffffffH
	DD	imagerel main$dtor$2
	DD	0ffffffffH
	DD	imagerel main$dtor$3
	DD	0ffffffffH
	DD	imagerel main$dtor$4
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$main DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$main
	DD	00H
	DD	00H
	DD	0bH
	DD	imagerel $ip2state$main
	DD	070H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	021a919H
	DD	05613f898H
	DD	05614e88fH
	DD	05615d886H
	DD	05616c87dH
	DD	05617b874H
	DD	05618a86bH
	DD	056199862H
	DD	0561a8859H
	DD	0561b7850H
	DD	0561c6848H
	DD	0ac427440H
	DD	0ac416438H
	DD	0ac403430H
	DD	0ac3a011fH
	DD	0e008f00aH
	DD	0c004d006H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$main
	DD	056122H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CTimer@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CTimer@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$max@M@std@@YAAEBMAEBM0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$max@M@std@@YAAEBMAEBM0@Z PROC			; std::max<float>, COMDAT

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	movss	xmm0, DWORD PTR [rdx]
	comiss	xmm0, DWORD PTR [rcx]
	cmova	rcx, rdx
	mov	rax, rcx

; 2033 : 	}

	ret	0
??$max@M@std@@YAAEBMAEBM0@Z ENDP			; std::max<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT main
_TEXT	SEGMENT
tv5381 = 32
qpcFreq$1 = 32
qpcFreq$2 = 32
qpcFreq$3 = 32
qpcFreq$4 = 32
qpcEnd$5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 32
$T14 = 32
$T15 = 32
$T16 = 32
$T17 = 32
$T18 = 32
absEpsilon$ = 40
tv5385 = 48
qpcEnd$19 = 48
qpcEnd$20 = 48
qpcEnd$21 = 48
qpcEnd$22 = 48
qpcFreq$23 = 48
timer$24 = 56
timer$25 = 56
timer$26 = 56
timer$27 = 56
timer$28 = 56
$T29 = 64
inAABBs_soa$30 = 64
$T31 = 112
cameraPos_aos$32 = 128
$T33 = 144
theMats_soa$34 = 272
translate$35 = 400
cameraPos$36 = 400
outAABBs_soa$37 = 416
worldToCamera_aos$38 = 416
$T39 = 480
worldToCamera$40 = 480
inXMaxs$41 = 544
outXMaxs$42 = 4544
outYMaxs$43 = 8544
inZMins$44 = 12544
outZMaxs$45 = 16544
inYMaxs$46 = 20544
inAABBs$47 = 24544
outXMins$48 = 48544
outAABBs$49 = 52544
outZMins$50 = 76544
inAABBs_aos$51 = 80544
inXMins$52 = 112544
outAABBs_aos$53 = 116544
outYMins$54 = 148544
mats$55 = 152544
inZMaxs$56 = 216544
mats_aos$57 = 220544
inYMins$58 = 284544
matComps_soa$59 = 288544
__$ArrayPad$ = 352544
main	PROC						; COMDAT

; 88   : {

$LN321:
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-352464]
	mov	eax, 352720				; 000561d0H
	call	__chkstk
	sub	rsp, rax
	mov	QWORD PTR $T31[rsp], -2
	mov	QWORD PTR [rsp+352768], rbx
	mov	QWORD PTR [rsp+352776], rsi
	mov	QWORD PTR [rsp+352784], rdi
	movaps	XMMWORD PTR [rsp+352704], xmm6
	movaps	XMMWORD PTR [rsp+352688], xmm7
	movaps	XMMWORD PTR [rsp+352672], xmm8
	movaps	XMMWORD PTR [rsp+352656], xmm9
	movaps	XMMWORD PTR [rsp+352640], xmm10
	movaps	XMMWORD PTR [rsp+352624], xmm11
	movaps	XMMWORD PTR [rsp+352608], xmm12
	movaps	XMMWORD PTR [rsp+352592], xmm13
	movaps	XMMWORD PTR [rsp+352576], xmm14
	movaps	XMMWORD PTR [rsp+352560], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 89   : 	float absEpsilon = 1e-5f;

	movss	xmm7, DWORD PTR __real@3727c5ac
	mov	DWORD PTR absEpsilon$[rsp], 925353388	; 3727c5acH

; 90   : 	float relEpsilon = 1e-5f;
; 91   : 
; 92   : 	{
; 93   : 		float yaw = 0.74f;
; 94   : 		float pitch = 0.47f;
; 95   : 		float cameraPos[] = { 1.0f, 2.0f, 3.0f };

	mov	DWORD PTR cameraPos$36[rbp-256], 1065353216 ; 3f800000H
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR cameraPos$36[rbp-252], xmm0
	movss	xmm1, DWORD PTR __real@40400000
	movss	DWORD PTR cameraPos$36[rbp-248], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@0000000040400000400000003f800000
	movaps	XMMWORD PTR cameraPos_aos$32[rbp-256], xmm0

; 96   : 		__m128 cameraPos_aos = { 1.0f, 2.0f, 3.0f };
; 97   : 		float worldToCamera[4][4];
; 98   : 		__m128 worldToCamera_aos[4];
; 99   : 
; 100  : #ifdef _DEBUG
; 101  : 		int trials = 1000000;
; 102  : #else
; 103  : 		int trials = 10000000;
; 104  : #endif
; 105  : 
; 106  : 		printf("calcWorldToCamera_FPU %dM times: ", trials/1000000);

	mov	edx, 10
	lea	rcx, OFFSET FLAT:??_C@_0CC@MHCKIHIN@calcWorldToCamera_FPU?5?$CFdM?5times?3@
	call	QWORD PTR __imp_printf

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	rcx, QWORD PTR timer$28[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter
	npad	1

; 89   : 	float absEpsilon = 1e-5f;

	mov	ebx, 10000000				; 00989680H
	mov	edi, ebx
	movss	xmm6, DWORD PTR __real@3ef0a3d7
	movss	xmm8, DWORD PTR __real@3f3d70a4
	npad	12
$LL44@main:

; 110  : 				calcWorldToCamera_FPU(yaw, pitch, cameraPos, worldToCamera);

	lea	r9, QWORD PTR worldToCamera$40[rbp-256]
	lea	r8, QWORD PTR cameraPos$36[rbp-256]
	movaps	xmm1, xmm6
	movaps	xmm0, xmm8
	call	?calcWorldToCamera_FPU@@YAXMMQEBMQEAY03M@Z ; calcWorldToCamera_FPU

; 107  : 		{
; 108  : 			CTimer timer;
; 109  : 			for (int i = 0; i < trials; ++i)

	dec	rdi
	jne	SHORT $LL44@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	rcx, QWORD PTR qpcEnd$5[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	rcx, QWORD PTR qpcFreq$23[rsp]
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	rax, QWORD PTR qpcEnd$5[rsp]
	sub	rax, QWORD PTR timer$28[rsp]
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, QWORD PTR qpcFreq$23[rsp]
	divss	xmm1, xmm0
	movss	xmm9, DWORD PTR __real@447a0000
	mulss	xmm1, xmm9
	cvtps2pd xmm1, xmm1
	movd	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	QWORD PTR __imp_printf

; 111  : 		}
; 112  : 
; 113  : 		printf("calcWorldToCamera_SSE_aos %dM times: ", trials/1000000);

	lea	edx, QWORD PTR [rdi+10]
	lea	rcx, OFFSET FLAT:??_C@_0CG@LJFHOHJE@calcWorldToCamera_SSE_aos?5?$CFdM?5ti@
	call	QWORD PTR __imp_printf

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	rcx, QWORD PTR timer$27[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter
	npad	1
	npad	12
$LL41@main:

; 117  : 				calcWorldToCamera_SSE_aos(yaw, pitch, cameraPos_aos, worldToCamera_aos);

	lea	r9, QWORD PTR worldToCamera_aos$38[rbp-256]
	lea	r8, QWORD PTR cameraPos_aos$32[rbp-256]
	movaps	xmm1, xmm6
	movaps	xmm0, xmm8
	call	?calcWorldToCamera_SSE_aos@@YAXMMAEBT__m128@@QEAT1@@Z ; calcWorldToCamera_SSE_aos

; 114  : 		{
; 115  : 			CTimer timer;
; 116  : 			for (int i = 0; i < trials; ++i)

	dec	rbx
	jne	SHORT $LL41@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	rcx, QWORD PTR qpcEnd$22[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	rcx, QWORD PTR qpcFreq$4[rsp]
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	rax, QWORD PTR qpcEnd$22[rsp]
	sub	rax, QWORD PTR timer$27[rsp]
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, QWORD PTR qpcFreq$4[rsp]
	divss	xmm1, xmm0
	mulss	xmm1, xmm9
	cvtps2pd xmm1, xmm1
	movd	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	QWORD PTR __imp_printf

; 119  : 
; 120  : 		for (int i = 0; i < 4; ++i)

	xor	r14d, r14d
	mov	esi, r14d

; 118  : 		}

	mov	ebx, r14d
	movsdx	xmm6, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	npad	3
$LL38@main:

; 121  : 		{
; 122  : 			for (int j = 0; j < 4; ++j)

	mov	edi, r14d
	npad	13
$LL35@main:
	movss	xmm1, DWORD PTR worldToCamera$40[rbp+rbx-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 125  : 						max(absEpsilon, relEpsilon * fabs(worldToCamera[i][j])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T18[rsp], xmm2
	subss	xmm1, DWORD PTR worldToCamera_aos$38[rbp+rbx-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T18[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 125  : 						max(absEpsilon, relEpsilon * fabs(worldToCamera[i][j])))

	comiss	xmm1, DWORD PTR [rax]
	jbe	SHORT $LN34@main

; 126  : 				{
; 127  : 					printf("Warning: significant mismatch in component [%d][%d]\n", i, j);

	mov	r8d, edi
	mov	edx, esi
	lea	rcx, OFFSET FLAT:??_C@_0DF@HEJBLKKF@Warning?3?5significant?5mismatch?5in@
	call	QWORD PTR __imp_printf
$LN34@main:

; 121  : 		{
; 122  : 			for (int j = 0; j < 4; ++j)

	inc	edi
	add	rbx, 4
	cmp	edi, 4
	jl	SHORT $LL35@main

; 119  : 
; 120  : 		for (int i = 0; i < 4; ++i)

	inc	esi
	cmp	esi, 4
	jl	SHORT $LL38@main

; 128  : 				}
; 129  : 			}
; 130  : 		}
; 131  : 	}
; 132  : 
; 133  : 	{
; 134  : 		const int n = 1000;
; 135  : 		AABB inAABBs[n];
; 136  : 		float mats[n][4][4];
; 137  : 		AABB outAABBs[n];
; 138  : 
; 139  : 		AABB_aos inAABBs_aos[n];
; 140  : 		__m128 mats_aos[n][4];
; 141  : 		AABB_aos outAABBs_aos[n];
; 142  : 
; 143  : 		__m128 inXMins[n/4];
; 144  : 		__m128 inYMins[n/4];
; 145  : 		__m128 inZMins[n/4];
; 146  : 		__m128 inXMaxs[n/4];
; 147  : 		__m128 inYMaxs[n/4];
; 148  : 		__m128 inZMaxs[n/4];
; 149  : 		AABBs_soa inAABBs_soa = { inXMins, inYMins, inZMins, inXMaxs, inYMaxs, inZMaxs };

	lea	rax, QWORD PTR inXMins$52[rbp-256]
	mov	QWORD PTR inAABBs_soa$30[rsp], rax
	lea	rax, QWORD PTR inYMins$58[rbp-256]
	mov	QWORD PTR inAABBs_soa$30[rsp+8], rax
	lea	rax, QWORD PTR inZMins$44[rbp-256]
	mov	QWORD PTR inAABBs_soa$30[rsp+16], rax
	lea	rax, QWORD PTR inXMaxs$41[rbp-256]
	mov	QWORD PTR inAABBs_soa$30[rsp+24], rax
	lea	rax, QWORD PTR inYMaxs$46[rbp-256]
	mov	QWORD PTR inAABBs_soa$30[rsp+32], rax
	lea	rax, QWORD PTR inZMaxs$56[rbp-256]
	mov	QWORD PTR inAABBs_soa$30[rsp+40], rax
	lea	rcx, QWORD PTR theMats_soa$34[rbp-248]
	lea	rdx, QWORD PTR matComps_soa$59[rbp+7744]
	mov	r8d, 4
$LL31@main:

; 154  : 			for (int j = 0; j < 4; ++j)
; 155  : 				theMats_soa.comps[i][j] = matComps_soa[i][j];

	lea	rax, QWORD PTR [rdx-8000]
	mov	QWORD PTR [rcx-8], rax
	lea	rax, QWORD PTR [rdx-4000]
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rdx
	lea	rax, QWORD PTR [rdx+4000]
	mov	QWORD PTR [rcx+16], rax

; 150  : 
; 151  : 		__m128 matComps_soa[4][4][n/4];
; 152  : 		mats_soa theMats_soa;
; 153  : 		for (int i = 0; i < 4; ++i)

	add	rdx, 16000				; 00003e80H
	lea	rcx, QWORD PTR [rcx+32]
	dec	r8
	jne	SHORT $LL31@main

; 156  : 
; 157  : 		__m128 outXMins[n/4];
; 158  : 		__m128 outYMins[n/4];
; 159  : 		__m128 outZMins[n/4];
; 160  : 		__m128 outXMaxs[n/4];
; 161  : 		__m128 outYMaxs[n/4];
; 162  : 		__m128 outZMaxs[n/4];
; 163  : 		AABBs_soa outAABBs_soa = { outXMins, outYMins, outZMins, outXMaxs, outYMaxs, outZMaxs };

	lea	rax, QWORD PTR outXMins$48[rbp-256]
	mov	QWORD PTR outAABBs_soa$37[rbp-256], rax
	lea	rax, QWORD PTR outYMins$54[rbp-256]
	mov	QWORD PTR outAABBs_soa$37[rbp-248], rax
	lea	rax, QWORD PTR outZMins$50[rbp-256]
	mov	QWORD PTR outAABBs_soa$37[rbp-240], rax
	lea	rax, QWORD PTR outXMaxs$42[rbp-256]
	mov	QWORD PTR outAABBs_soa$37[rbp-232], rax
	lea	rax, QWORD PTR outYMaxs$43[rbp-256]
	mov	QWORD PTR outAABBs_soa$37[rbp-224], rax
	lea	rax, QWORD PTR outZMaxs$45[rbp-256]
	mov	QWORD PTR outAABBs_soa$37[rbp-216], rax

; 48   : 	}
; 49   : };
; 50   : 
; 51   : // Quick simple RNG based on Xorhash
; 52   : struct RNG
; 53   : {
; 54   : 	unsigned int m_state;
; 55   : 
; 56   : 	void seed(unsigned int seed)
; 57   : 	{
; 58   : 		// Thomas Wang's integer hash, as reported by Bob Jenkins
; 59   : 		seed = (seed ^ 61) ^ (seed >> 16);
; 60   : 		seed *= 9;
; 61   : 		seed = seed ^ (seed >> 4);
; 62   : 		seed *= 0x27d4eb2d;
; 63   : 		seed = seed ^ (seed >> 15);
; 64   : 		m_state = seed;

	mov	ebx, 599397116				; 23ba12fcH

; 164  : 
; 165  : 		// Fill all three sets of inputs with some randomly generated data
; 166  : 		RNG rng;
; 167  : 		rng.seed(47);
; 168  : 		for (int i = 0; i < n; ++i)

	mov	r15d, r14d
	xorps	xmm11, xmm11
	movaps	xmm8, xmm11
	subss	xmm8, DWORD PTR __real@40c90fd0

; 156  : 
; 157  : 		__m128 outXMins[n/4];
; 158  : 		__m128 outYMins[n/4];
; 159  : 		__m128 outZMins[n/4];
; 160  : 		__m128 outXMaxs[n/4];
; 161  : 		__m128 outYMaxs[n/4];
; 162  : 		__m128 outZMaxs[n/4];
; 163  : 		AABBs_soa outAABBs_soa = { outXMins, outYMins, outZMins, outXMaxs, outYMaxs, outZMaxs };

	mov	rsi, r14
	lea	r12, QWORD PTR inAABBs$47[rbp-252]
	lea	r13, QWORD PTR inAABBs_aos$51[rbp-252]
	lea	rdx, QWORD PTR mats$55[rbp-256]
	mov	QWORD PTR tv5381[rsp], rdx
	movss	xmm10, DWORD PTR __real@2f800000
	movss	xmm12, DWORD PTR __real@41a00000
	movss	xmm13, DWORD PTR __real@c1200000
	movss	xmm14, DWORD PTR __real@41100000
	movss	xmm15, DWORD PTR __real@40c00000
$LL25@main:

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm12
	movaps	xmm4, xmm13
	subss	xmm4, xmm0

; 169  : 		{
; 170  : 			inAABBs[i].mins[0] = inAABBs_aos[i].mins.m128_f32[0] = inXMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	mov	ecx, r15d
	shr	ecx, 2
	mov	rax, r14
	and	eax, 3
	lea	rdi, QWORD PTR [rax+rcx*4]
	movss	DWORD PTR inXMins$52[rbp+rdi*4-256], xmm4
	movss	DWORD PTR [r13-4], xmm4
	movss	DWORD PTR [r12-4], xmm4

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm12
	movaps	xmm2, xmm13
	subss	xmm2, xmm0

; 171  : 			inAABBs[i].mins[1] = inAABBs_aos[i].mins.m128_f32[1] = inYMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	movss	DWORD PTR inYMins$58[rbp+rdi*4-256], xmm2
	movss	DWORD PTR [r13], xmm2
	movss	DWORD PTR [r12], xmm2

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm12
	movaps	xmm3, xmm13
	subss	xmm3, xmm0

; 172  : 			inAABBs[i].mins[2] = inAABBs_aos[i].mins.m128_f32[2] = inZMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	movss	DWORD PTR inZMins$44[rbp+rdi*4-256], xmm3
	movss	DWORD PTR [r13+4], xmm3
	movss	DWORD PTR [r12+4], xmm3

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm14
	movss	xmm5, DWORD PTR __real@3f800000
	movaps	xmm1, xmm5
	subss	xmm1, xmm0

; 173  : 			inAABBs[i].maxs[0] = inAABBs_aos[i].maxs.m128_f32[0] = inXMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[0] + rng.randFloat(1, 10);

	addss	xmm1, xmm4
	movss	DWORD PTR inXMaxs$41[rbp+rdi*4-256], xmm1
	movss	DWORD PTR [r13+12], xmm1
	movss	DWORD PTR [r12+8], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm14
	movaps	xmm1, xmm5
	subss	xmm1, xmm0

; 174  : 			inAABBs[i].maxs[1] = inAABBs_aos[i].maxs.m128_f32[1] = inYMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[1] + rng.randFloat(1, 10);

	addss	xmm1, xmm2
	movss	DWORD PTR inYMaxs$46[rbp+rdi*4-256], xmm1
	movss	DWORD PTR [r13+16], xmm1
	movss	DWORD PTR [r12+12], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm14
	movaps	xmm1, xmm5
	subss	xmm1, xmm0

; 175  : 			inAABBs[i].maxs[2] = inAABBs_aos[i].maxs.m128_f32[2] = inZMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[2] + rng.randFloat(1, 10);

	addss	xmm1, xmm3
	movss	DWORD PTR inZMaxs$56[rbp+rdi*4-256], xmm1
	movss	DWORD PTR [r13+20], xmm1
	movss	DWORD PTR [r12+16], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	mulss	xmm1, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm1, xmm12
	movaps	xmm0, xmm13
	subss	xmm0, xmm1

; 176  : 
; 177  : 			float translate[] = { rng.randFloat(-10, 10), rng.randFloat(-10, 10), rng.randFloat(-10, 10) };

	movss	DWORD PTR translate$35[rbp-256], xmm0

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	mulss	xmm1, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm1, xmm12
	movaps	xmm0, xmm13
	subss	xmm0, xmm1

; 176  : 
; 177  : 			float translate[] = { rng.randFloat(-10, 10), rng.randFloat(-10, 10), rng.randFloat(-10, 10) };

	movss	DWORD PTR translate$35[rbp-252], xmm0

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	mulss	xmm1, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm1, xmm12
	movaps	xmm0, xmm13
	subss	xmm0, xmm1

; 176  : 
; 177  : 			float translate[] = { rng.randFloat(-10, 10), rng.randFloat(-10, 10), rng.randFloat(-10, 10) };

	movss	DWORD PTR translate$35[rbp-248], xmm0

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax

; 73   : 		return m_state;

	mov	ecx, ebx

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, ebx
	shl	eax, 13
	xor	ebx, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, ebx
	shr	eax, 17
	xor	ebx, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, ebx
	shl	eax, 5
	xor	ebx, eax
	xorps	xmm0, xmm0

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtsi2ss xmm0, rcx
	mulss	xmm0, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm15
	movss	xmm1, DWORD PTR __real@c0400000
	subss	xmm1, xmm0

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, ebx
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm10

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm8
	addss	xmm0, xmm11

; 178  : 			calcWorldToCamera_FPU(rng.randFloat(0, 2.0f*3.14159f), rng.randFloat(-3.0f, 3.0f), translate, mats[i]);

	mov	r9, rdx
	lea	r8, QWORD PTR translate$35[rbp-256]
	call	?calcWorldToCamera_FPU@@YAXMMQEBMQEAY03M@Z ; calcWorldToCamera_FPU

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	lea	rax, QWORD PTR matComps_soa$59[rbp+3744]
	lea	rax, QWORD PTR [rax+rdi*4]
	mov	ecx, 4
$LL22@main:

; 180  : 				for (int k = 0; k < 4; ++k)
; 181  : 					matComps_soa[j][k][i/4].m128_f32[i%4] = mats_aos[i][j].m128_f32[k] = mats[i][j][k];

	movss	xmm0, DWORD PTR mats$55[rbp+rsi-256]
	movss	DWORD PTR mats_aos$57[rbp+rsi-256], xmm0
	movss	DWORD PTR [rax-4000], xmm0
	movss	xmm1, DWORD PTR mats$55[rbp+rsi-252]
	movss	DWORD PTR mats_aos$57[rbp+rsi-252], xmm1
	movss	DWORD PTR [rax], xmm1
	movss	xmm0, DWORD PTR mats$55[rbp+rsi-248]
	movss	DWORD PTR mats_aos$57[rbp+rsi-248], xmm0
	movss	DWORD PTR [rax+4000], xmm0
	movss	xmm1, DWORD PTR mats$55[rbp+rsi-244]
	movss	DWORD PTR mats_aos$57[rbp+rsi-244], xmm1
	movss	DWORD PTR [rax+8000], xmm1
	add	rsi, 16

; 179  : 			for (int j = 0; j < 4; ++j)

	lea	rax, QWORD PTR [rax+16000]
	dec	rcx
	jne	SHORT $LL22@main

; 164  : 
; 165  : 		// Fill all three sets of inputs with some randomly generated data
; 166  : 		RNG rng;
; 167  : 		rng.seed(47);
; 168  : 		for (int i = 0; i < n; ++i)

	inc	r15d
	inc	r14
	mov	rdx, QWORD PTR tv5381[rsp]
	add	rdx, 64					; 00000040H
	mov	QWORD PTR tv5381[rsp], rdx
	add	r13, 32					; 00000020H
	add	r12, 24
	cmp	r15d, 1000				; 000003e8H
	jl	$LL25@main

; 182  : 		}
; 183  : 
; 184  : #ifdef _DEBUG
; 185  : 		int trials = 100;
; 186  : #else
; 187  : 		int trials = 10000;
; 188  : #endif
; 189  : 
; 190  : 		printf("transformAABBs_FPU, %dK AABBs, %dK times: ", n/1000, trials/1000);

	lea	edx, QWORD PTR [rcx+1]
	lea	r8d, QWORD PTR [rcx+10]
	lea	rcx, OFFSET FLAT:??_C@_0CL@PDOPMEAA@transformAABBs_FPU?0?5?$CFdK?5AABBs?0?5?$CF@
	call	QWORD PTR __imp_printf

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	rcx, QWORD PTR timer$26[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter
	npad	1

; 182  : 		}
; 183  : 
; 184  : #ifdef _DEBUG
; 185  : 		int trials = 100;
; 186  : #else
; 187  : 		int trials = 10000;
; 188  : #endif
; 189  : 
; 190  : 		printf("transformAABBs_FPU, %dK AABBs, %dK times: ", n/1000, trials/1000);

	mov	edi, 10000				; 00002710H
	mov	ebx, edi
	xor	r14d, r14d
	npad	2
$LL16@main:

; 194  : 				transformAABBs_FPU(n, inAABBs, mats, outAABBs);

	lea	r9, QWORD PTR outAABBs$49[rbp-256]
	lea	r8, QWORD PTR mats$55[rbp-256]
	lea	rdx, QWORD PTR inAABBs$47[rbp-256]
	mov	ecx, 1000				; 000003e8H
	call	?transformAABBs_FPU@@YAXHPEBUAABB@@QEAY133$$CBMPEAU1@@Z ; transformAABBs_FPU

; 191  : 		{
; 192  : 			CTimer timer;
; 193  : 			for (int i = 0; i < trials; ++i)

	dec	rbx
	jne	SHORT $LL16@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	rcx, QWORD PTR qpcEnd$21[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	rcx, QWORD PTR qpcFreq$3[rsp]
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	rax, QWORD PTR qpcEnd$21[rsp]
	sub	rax, QWORD PTR timer$26[rsp]
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, QWORD PTR qpcFreq$3[rsp]
	divss	xmm1, xmm0
	mulss	xmm1, xmm9
	cvtps2pd xmm1, xmm1
	movd	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	QWORD PTR __imp_printf

; 196  : 
; 197  : 		printf("transformAABBs_SSE_aos, %dK AABBs, %dK times: ", n/1000, trials/1000);

	lea	edx, QWORD PTR [rbx+1]
	lea	r8d, QWORD PTR [rbx+10]
	lea	rcx, OFFSET FLAT:??_C@_0CP@GOAMJCGE@transformAABBs_SSE_aos?0?5?$CFdK?5AABB@
	call	QWORD PTR __imp_printf

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	rcx, QWORD PTR timer$25[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter
	npad	1

; 195  : 		}

	mov	rbx, rdi
	npad	9
$LL13@main:

; 201  : 				transformAABBs_SSE_aos(n, inAABBs_aos, mats_aos, outAABBs_aos);

	lea	r9, QWORD PTR outAABBs_aos$53[rbp-256]
	lea	r8, QWORD PTR mats_aos$57[rbp-256]
	lea	rdx, QWORD PTR inAABBs_aos$51[rbp-256]
	mov	ecx, 1000				; 000003e8H
	call	?transformAABBs_SSE_aos@@YAXHPEBUAABB_aos@@QEAY03$$CBT__m128@@PEAU1@@Z ; transformAABBs_SSE_aos

; 198  : 		{
; 199  : 			CTimer timer;
; 200  : 			for (int i = 0; i < trials; ++i)

	dec	rbx
	jne	SHORT $LL13@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	rcx, QWORD PTR qpcEnd$20[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	rcx, QWORD PTR qpcFreq$2[rsp]
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	rax, QWORD PTR qpcEnd$20[rsp]
	sub	rax, QWORD PTR timer$25[rsp]
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, QWORD PTR qpcFreq$2[rsp]
	divss	xmm1, xmm0
	mulss	xmm1, xmm9
	cvtps2pd xmm1, xmm1
	movd	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	QWORD PTR __imp_printf

; 203  : 
; 204  : 		printf("transformAABBs_SSE_soa, %dK AABBs, %dK times: ", n/1000, trials/1000);

	lea	edx, QWORD PTR [rbx+1]
	lea	r8d, QWORD PTR [rbx+10]
	lea	rcx, OFFSET FLAT:??_C@_0CP@MJCAKJJJ@transformAABBs_SSE_soa?0?5?$CFdK?5AABB@
	call	QWORD PTR __imp_printf

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	rcx, QWORD PTR timer$24[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter
	npad	1

; 202  : 		}

	movsdx	xmm8, QWORD PTR inAABBs_soa$30[rsp+40]
	movsdx	xmm9, QWORD PTR inAABBs_soa$30[rsp+32]
	movsdx	xmm10, QWORD PTR inAABBs_soa$30[rsp+24]
	movsdx	xmm11, QWORD PTR inAABBs_soa$30[rsp+16]
	movsdx	xmm12, QWORD PTR inAABBs_soa$30[rsp+8]
	movsdx	xmm13, QWORD PTR inAABBs_soa$30[rsp]
	movaps	xmm14, XMMWORD PTR theMats_soa$34[rbp-144]
	movaps	xmm15, XMMWORD PTR theMats_soa$34[rbp-160]
	movaps	xmm7, XMMWORD PTR theMats_soa$34[rbp-176]
	movaps	xmm6, XMMWORD PTR theMats_soa$34[rbp-192]
	npad	13
$LL10@main:

; 208  : 				transformAABBs_SSE_soa(n, inAABBs_soa, theMats_soa, outAABBs_soa);

	movsdx	xmm0, QWORD PTR outAABBs_soa$37[rbp-256]
	movsdx	QWORD PTR $T29[rsp], xmm0
	movsdx	xmm0, QWORD PTR outAABBs_soa$37[rbp-248]
	movsdx	QWORD PTR $T29[rsp+8], xmm0
	movsdx	xmm0, QWORD PTR outAABBs_soa$37[rbp-240]
	movsdx	QWORD PTR $T29[rsp+16], xmm0
	movsdx	xmm0, QWORD PTR outAABBs_soa$37[rbp-232]
	movsdx	QWORD PTR $T29[rsp+24], xmm0
	movsdx	xmm0, QWORD PTR outAABBs_soa$37[rbp-224]
	movsdx	QWORD PTR $T29[rsp+32], xmm0
	movsdx	xmm0, QWORD PTR outAABBs_soa$37[rbp-216]
	movsdx	QWORD PTR $T29[rsp+40], xmm0
	movaps	xmm0, XMMWORD PTR theMats_soa$34[rbp-256]
	movaps	XMMWORD PTR $T33[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR theMats_soa$34[rbp-240]
	movaps	XMMWORD PTR $T33[rbp-240], xmm0
	movaps	xmm0, XMMWORD PTR theMats_soa$34[rbp-224]
	movaps	XMMWORD PTR $T33[rbp-224], xmm0
	movaps	xmm0, XMMWORD PTR theMats_soa$34[rbp-208]
	movaps	XMMWORD PTR $T33[rbp-208], xmm0
	movaps	XMMWORD PTR $T33[rbp-192], xmm6
	movaps	XMMWORD PTR $T33[rbp-176], xmm7
	movaps	XMMWORD PTR $T33[rbp-160], xmm15
	movaps	XMMWORD PTR $T33[rbp-144], xmm14
	movsdx	QWORD PTR $T39[rbp-256], xmm13
	movsdx	QWORD PTR $T39[rbp-248], xmm12
	movsdx	QWORD PTR $T39[rbp-240], xmm11
	movsdx	QWORD PTR $T39[rbp-232], xmm10
	movsdx	QWORD PTR $T39[rbp-224], xmm9
	movsdx	QWORD PTR $T39[rbp-216], xmm8
	lea	r9, QWORD PTR $T29[rsp]
	lea	r8, QWORD PTR $T33[rbp-256]
	lea	rdx, QWORD PTR $T39[rbp-256]
	mov	ecx, 1000				; 000003e8H
	call	?transformAABBs_SSE_soa@@YAXHUAABBs_soa@@Umats_soa@@0@Z ; transformAABBs_SSE_soa

; 205  : 		{
; 206  : 			CTimer timer;
; 207  : 			for (int i = 0; i < trials; ++i)

	dec	rdi
	jne	$LL10@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	rcx, QWORD PTR qpcEnd$19[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	rcx, QWORD PTR qpcFreq$1[rsp]
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	rax, QWORD PTR qpcEnd$19[rsp]
	sub	rax, QWORD PTR timer$24[rsp]
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, QWORD PTR qpcFreq$1[rsp]
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@447a0000
	cvtps2pd xmm1, xmm1
	movd	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	QWORD PTR __imp_printf

; 209  : 		}

	mov	rsi, r14
	lea	rbx, QWORD PTR outAABBs$49[rbp-252]
	lea	rdi, QWORD PTR outAABBs_aos$53[rbp-252]
	movsdx	xmm6, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movss	xmm7, DWORD PTR __real@3727c5ac
	npad	13
$LL7@main:
	movss	xmm1, DWORD PTR [rbx-4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T17[rsp], xmm2
	subss	xmm1, DWORD PTR [rdi-4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T17[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	$LN3@main
	movss	xmm1, DWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T16[rsp], xmm2
	subss	xmm1, DWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T16[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	$LN3@main
	movss	xmm1, DWORD PTR [rbx+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T15[rsp], xmm2
	subss	xmm1, DWORD PTR [rdi+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T15[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	$LN3@main
	movss	xmm1, DWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T14[rsp], xmm2
	subss	xmm1, DWORD PTR [rdi+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T14[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	$LN3@main
	movss	xmm1, DWORD PTR [rbx+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T13[rsp], xmm2
	subss	xmm1, DWORD PTR [rdi+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T13[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	SHORT $LN3@main
	movss	xmm1, DWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T12[rsp], xmm2
	subss	xmm1, DWORD PTR [rdi+20]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T12[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	jbe	SHORT $LN4@main
$LN3@main:

; 219  : 			{
; 220  : 				printf("Warning: significant mismatch in AOS bounding box %d\n", i);

	mov	edx, r14d
	lea	rcx, OFFSET FLAT:??_C@_0DG@FAFHICNP@Warning?3?5significant?5mismatch?5in@
	call	QWORD PTR __imp_printf
$LN4@main:
	movss	xmm1, DWORD PTR [rbx-4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T11[rsp], xmm2
	mov	ecx, r14d
	shr	ecx, 2
	mov	rax, rsi
	and	eax, 3
	lea	rdx, QWORD PTR [rax+rcx*4]
	subss	xmm1, DWORD PTR outXMins$48[rbp+rdx*4-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	$LN1@main
	movss	xmm1, DWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T10[rsp], xmm2
	subss	xmm1, DWORD PTR outYMins$54[rbp+rdx*4-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T10[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	$LN1@main
	movss	xmm1, DWORD PTR [rbx+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T9[rsp], xmm2
	subss	xmm1, DWORD PTR outZMins$50[rbp+rdx*4-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T9[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	$LN1@main
	movss	xmm1, DWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T8[rsp], xmm2
	subss	xmm1, DWORD PTR outXMaxs$42[rbp+rdx*4-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T8[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	$LN1@main
	movss	xmm1, DWORD PTR [rbx+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T7[rsp], xmm2
	subss	xmm1, DWORD PTR outYMaxs$43[rbp+rdx*4-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	ja	SHORT $LN1@main
	movss	xmm1, DWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm7
	movss	DWORD PTR $T6[rsp], xmm2
	subss	xmm1, DWORD PTR outZMaxs$45[rbp+rdx*4-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm6
	cvtpd2ps xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	rax, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR absEpsilon$[rsp]
	comiss	xmm2, xmm7
	cmovbe	rax, rcx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	comiss	xmm1, DWORD PTR [rax]
	jbe	SHORT $LN6@main
$LN1@main:

; 228  : 			{
; 229  : 				printf("Warning: significant mismatch in SOA bounding box %d\n", i);

	mov	edx, r14d
	lea	rcx, OFFSET FLAT:??_C@_0DG@JIIBKMLF@Warning?3?5significant?5mismatch?5in@
	call	QWORD PTR __imp_printf
$LN6@main:

; 210  : 
; 211  : 		for (int i = 0; i < n; ++i)

	inc	r14d
	inc	rsi
	add	rdi, 32					; 00000020H
	add	rbx, 24
	cmp	r14d, 1000				; 000003e8H
	jl	$LL7@main

; 230  : 			}
; 231  : 		}
; 232  : 	}
; 233  : 
; 234  : 	return 0;

	xor	eax, eax

; 235  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+352720]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	movaps	xmm15, XMMWORD PTR [r11-160]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5381 = 32
qpcFreq$1 = 32
qpcFreq$2 = 32
qpcFreq$3 = 32
qpcFreq$4 = 32
qpcEnd$5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 32
$T14 = 32
$T15 = 32
$T16 = 32
$T17 = 32
$T18 = 32
absEpsilon$ = 40
tv5385 = 48
qpcEnd$19 = 48
qpcEnd$20 = 48
qpcEnd$21 = 48
qpcEnd$22 = 48
qpcFreq$23 = 48
timer$24 = 56
timer$25 = 56
timer$26 = 56
timer$27 = 56
timer$28 = 56
$T29 = 64
inAABBs_soa$30 = 64
$T31 = 112
cameraPos_aos$32 = 128
$T33 = 144
theMats_soa$34 = 272
translate$35 = 400
cameraPos$36 = 400
outAABBs_soa$37 = 416
worldToCamera_aos$38 = 416
$T39 = 480
worldToCamera$40 = 480
inXMaxs$41 = 544
outXMaxs$42 = 4544
outYMaxs$43 = 8544
inZMins$44 = 12544
outZMaxs$45 = 16544
inYMaxs$46 = 20544
inAABBs$47 = 24544
outXMins$48 = 48544
outAABBs$49 = 52544
outZMins$50 = 76544
inAABBs_aos$51 = 80544
inXMins$52 = 112544
outAABBs_aos$53 = 116544
outYMins$54 = 148544
mats$55 = 152544
inZMaxs$56 = 216544
mats_aos$57 = 220544
inYMins$58 = 284544
matComps_soa$59 = 288544
__$ArrayPad$ = 352544
main$dtor$0 PROC
	lea	rcx, QWORD PTR timer$28[rdx]
	jmp	??1CTimer@@QEAA@XZ			; CTimer::~CTimer
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5381 = 32
qpcFreq$1 = 32
qpcFreq$2 = 32
qpcFreq$3 = 32
qpcFreq$4 = 32
qpcEnd$5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 32
$T14 = 32
$T15 = 32
$T16 = 32
$T17 = 32
$T18 = 32
absEpsilon$ = 40
tv5385 = 48
qpcEnd$19 = 48
qpcEnd$20 = 48
qpcEnd$21 = 48
qpcEnd$22 = 48
qpcFreq$23 = 48
timer$24 = 56
timer$25 = 56
timer$26 = 56
timer$27 = 56
timer$28 = 56
$T29 = 64
inAABBs_soa$30 = 64
$T31 = 112
cameraPos_aos$32 = 128
$T33 = 144
theMats_soa$34 = 272
translate$35 = 400
cameraPos$36 = 400
outAABBs_soa$37 = 416
worldToCamera_aos$38 = 416
$T39 = 480
worldToCamera$40 = 480
inXMaxs$41 = 544
outXMaxs$42 = 4544
outYMaxs$43 = 8544
inZMins$44 = 12544
outZMaxs$45 = 16544
inYMaxs$46 = 20544
inAABBs$47 = 24544
outXMins$48 = 48544
outAABBs$49 = 52544
outZMins$50 = 76544
inAABBs_aos$51 = 80544
inXMins$52 = 112544
outAABBs_aos$53 = 116544
outYMins$54 = 148544
mats$55 = 152544
inZMaxs$56 = 216544
mats_aos$57 = 220544
inYMins$58 = 284544
matComps_soa$59 = 288544
__$ArrayPad$ = 352544
main$dtor$1 PROC
	lea	rcx, QWORD PTR timer$27[rdx]
	jmp	??1CTimer@@QEAA@XZ			; CTimer::~CTimer
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5381 = 32
qpcFreq$1 = 32
qpcFreq$2 = 32
qpcFreq$3 = 32
qpcFreq$4 = 32
qpcEnd$5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 32
$T14 = 32
$T15 = 32
$T16 = 32
$T17 = 32
$T18 = 32
absEpsilon$ = 40
tv5385 = 48
qpcEnd$19 = 48
qpcEnd$20 = 48
qpcEnd$21 = 48
qpcEnd$22 = 48
qpcFreq$23 = 48
timer$24 = 56
timer$25 = 56
timer$26 = 56
timer$27 = 56
timer$28 = 56
$T29 = 64
inAABBs_soa$30 = 64
$T31 = 112
cameraPos_aos$32 = 128
$T33 = 144
theMats_soa$34 = 272
translate$35 = 400
cameraPos$36 = 400
outAABBs_soa$37 = 416
worldToCamera_aos$38 = 416
$T39 = 480
worldToCamera$40 = 480
inXMaxs$41 = 544
outXMaxs$42 = 4544
outYMaxs$43 = 8544
inZMins$44 = 12544
outZMaxs$45 = 16544
inYMaxs$46 = 20544
inAABBs$47 = 24544
outXMins$48 = 48544
outAABBs$49 = 52544
outZMins$50 = 76544
inAABBs_aos$51 = 80544
inXMins$52 = 112544
outAABBs_aos$53 = 116544
outYMins$54 = 148544
mats$55 = 152544
inZMaxs$56 = 216544
mats_aos$57 = 220544
inYMins$58 = 284544
matComps_soa$59 = 288544
__$ArrayPad$ = 352544
main$dtor$2 PROC
	lea	rcx, QWORD PTR timer$26[rdx]
	jmp	??1CTimer@@QEAA@XZ			; CTimer::~CTimer
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5381 = 32
qpcFreq$1 = 32
qpcFreq$2 = 32
qpcFreq$3 = 32
qpcFreq$4 = 32
qpcEnd$5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 32
$T14 = 32
$T15 = 32
$T16 = 32
$T17 = 32
$T18 = 32
absEpsilon$ = 40
tv5385 = 48
qpcEnd$19 = 48
qpcEnd$20 = 48
qpcEnd$21 = 48
qpcEnd$22 = 48
qpcFreq$23 = 48
timer$24 = 56
timer$25 = 56
timer$26 = 56
timer$27 = 56
timer$28 = 56
$T29 = 64
inAABBs_soa$30 = 64
$T31 = 112
cameraPos_aos$32 = 128
$T33 = 144
theMats_soa$34 = 272
translate$35 = 400
cameraPos$36 = 400
outAABBs_soa$37 = 416
worldToCamera_aos$38 = 416
$T39 = 480
worldToCamera$40 = 480
inXMaxs$41 = 544
outXMaxs$42 = 4544
outYMaxs$43 = 8544
inZMins$44 = 12544
outZMaxs$45 = 16544
inYMaxs$46 = 20544
inAABBs$47 = 24544
outXMins$48 = 48544
outAABBs$49 = 52544
outZMins$50 = 76544
inAABBs_aos$51 = 80544
inXMins$52 = 112544
outAABBs_aos$53 = 116544
outYMins$54 = 148544
mats$55 = 152544
inZMaxs$56 = 216544
mats_aos$57 = 220544
inYMins$58 = 284544
matComps_soa$59 = 288544
__$ArrayPad$ = 352544
main$dtor$3 PROC
	lea	rcx, QWORD PTR timer$25[rdx]
	jmp	??1CTimer@@QEAA@XZ			; CTimer::~CTimer
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv5381 = 32
qpcFreq$1 = 32
qpcFreq$2 = 32
qpcFreq$3 = 32
qpcFreq$4 = 32
qpcEnd$5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 32
$T12 = 32
$T13 = 32
$T14 = 32
$T15 = 32
$T16 = 32
$T17 = 32
$T18 = 32
absEpsilon$ = 40
tv5385 = 48
qpcEnd$19 = 48
qpcEnd$20 = 48
qpcEnd$21 = 48
qpcEnd$22 = 48
qpcFreq$23 = 48
timer$24 = 56
timer$25 = 56
timer$26 = 56
timer$27 = 56
timer$28 = 56
$T29 = 64
inAABBs_soa$30 = 64
$T31 = 112
cameraPos_aos$32 = 128
$T33 = 144
theMats_soa$34 = 272
translate$35 = 400
cameraPos$36 = 400
outAABBs_soa$37 = 416
worldToCamera_aos$38 = 416
$T39 = 480
worldToCamera$40 = 480
inXMaxs$41 = 544
outXMaxs$42 = 4544
outYMaxs$43 = 8544
inZMins$44 = 12544
outZMaxs$45 = 16544
inYMaxs$46 = 20544
inAABBs$47 = 24544
outXMins$48 = 48544
outAABBs$49 = 52544
outZMins$50 = 76544
inAABBs_aos$51 = 80544
inXMins$52 = 112544
outAABBs_aos$53 = 116544
outYMins$54 = 148544
mats$55 = 152544
inZMaxs$56 = 216544
mats_aos$57 = 220544
inYMins$58 = 284544
matComps_soa$59 = 288544
__$ArrayPad$ = 352544
main$dtor$4 PROC
	lea	rcx, QWORD PTR timer$24[rdx]
	jmp	??1CTimer@@QEAA@XZ			; CTimer::~CTimer
main$dtor$4 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?randFloat@RNG@@QEAAMMM@Z
_TEXT	SEGMENT
this$ = 8
min$ = 16
max$ = 24
?randFloat@RNG@@QEAAMMM@Z PROC				; RNG::randFloat, COMDAT

; 70   : 		m_state ^= (m_state << 13);

	mov	edx, DWORD PTR [rcx]

; 82   : 	{

	mov	r9, rcx
	movaps	xmm3, xmm1

; 83   : 		return min + (min - max)*randFloat();

	movaps	xmm0, xmm1

; 70   : 		m_state ^= (m_state << 13);

	shl	edx, 13
	xor	edx, DWORD PTR [rcx]
	xorps	xmm1, xmm1

; 71   : 		m_state ^= (m_state >> 17);

	mov	r8d, edx

; 83   : 		return min + (min - max)*randFloat();

	subss	xmm0, xmm2

; 71   : 		m_state ^= (m_state >> 17);

	shr	r8d, 17
	xor	r8d, edx

; 72   : 		m_state ^= (m_state << 5);

	mov	ecx, r8d
	shl	ecx, 5
	xor	ecx, r8d
	mov	DWORD PTR [r9], ecx

; 73   : 		return m_state;
; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtsi2ss xmm1, rcx
	mulss	xmm1, DWORD PTR __real@2f800000

; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm1
	addss	xmm0, xmm3

; 84   : 	}

	ret	0
?randFloat@RNG@@QEAAMMM@Z ENDP				; RNG::randFloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?randFloat@RNG@@QEAAMXZ
_TEXT	SEGMENT
this$ = 8
?randFloat@RNG@@QEAAMXZ PROC				; RNG::randFloat, COMDAT

; 70   : 		m_state ^= (m_state << 13);

	mov	edx, DWORD PTR [rcx]
	xorps	xmm0, xmm0
	shl	edx, 13
	xor	edx, DWORD PTR [rcx]

; 71   : 		m_state ^= (m_state >> 17);

	mov	r8d, edx
	shr	r8d, 17
	xor	r8d, edx

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, r8d
	shl	eax, 5
	xor	eax, r8d
	mov	DWORD PTR [rcx], eax

; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtsi2ss xmm0, rax
	mulss	xmm0, DWORD PTR __real@2f800000

; 79   : 	}

	ret	0
?randFloat@RNG@@QEAAMXZ ENDP				; RNG::randFloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?randUint@RNG@@QEAAIXZ
_TEXT	SEGMENT
this$ = 8
?randUint@RNG@@QEAAIXZ PROC				; RNG::randUint, COMDAT

; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	edx, DWORD PTR [rcx]
	shl	edx, 13
	xor	edx, DWORD PTR [rcx]

; 71   : 		m_state ^= (m_state >> 17);

	mov	r8d, edx
	shr	r8d, 17
	xor	r8d, edx

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, r8d
	shl	eax, 5
	xor	eax, r8d
	mov	DWORD PTR [rcx], eax

; 73   : 		return m_state;
; 74   : 	}

	ret	0
?randUint@RNG@@QEAAIXZ ENDP				; RNG::randUint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?seed@RNG@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
seed$ = 16
?seed@RNG@@QEAAXI@Z PROC				; RNG::seed, COMDAT

; 58   : 		// Thomas Wang's integer hash, as reported by Bob Jenkins
; 59   : 		seed = (seed ^ 61) ^ (seed >> 16);
; 60   : 		seed *= 9;

	mov	eax, edx
	xor	eax, 3997696				; 003d0000H
	shr	eax, 16
	xor	eax, edx
	lea	eax, DWORD PTR [rax+rax*8]

; 61   : 		seed = seed ^ (seed >> 4);

	mov	edx, eax
	shr	edx, 4
	xor	edx, eax

; 62   : 		seed *= 0x27d4eb2d;

	imul	edx, 668265261				; 27d4eb2dH

; 63   : 		seed = seed ^ (seed >> 15);

	mov	eax, edx
	shr	eax, 15
	xor	eax, edx

; 64   : 		m_state = seed;

	mov	DWORD PTR [rcx], eax

; 65   : 	}

	ret	0
?seed@RNG@@QEAAXI@Z ENDP				; RNG::seed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ??1CTimer@@QEAA@XZ
_TEXT	SEGMENT
qpcEnd$ = 48
this$ = 48
qpcFreq$ = 56
??1CTimer@@QEAA@XZ PROC					; CTimer::~CTimer, COMDAT

; 43   : 	{

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	rcx, QWORD PTR qpcEnd$[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	rcx, QWORD PTR qpcFreq$[rsp]
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	rax, QWORD PTR qpcEnd$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	xorps	xmm1, xmm1
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, QWORD PTR qpcFreq$[rsp]
	sub	rax, QWORD PTR [rbx]
	cvtsi2ss xmm1, rax
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@447a0000
	cvtps2pd xmm1, xmm1
	movd	rdx, xmm1
	call	QWORD PTR __imp_printf

; 48   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1CTimer@@QEAA@XZ ENDP					; CTimer::~CTimer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ??0CTimer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0CTimer@@QEAA@XZ PROC					; CTimer::CTimer, COMDAT

; 38   : 	CTimer()

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 39   : 	{
; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	call	QWORD PTR __imp_QueryPerformanceCounter

; 41   : 	}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0CTimer@@QEAA@XZ ENDP					; CTimer::CTimer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
_X$ = 8
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	xorps	xmm1, xmm1

; 392  :         {return ((float)fabs((double)_X)); }

	cvtss2sd xmm1, xmm0
	andpd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm1

; 517  :         {return (fabsf(_X)); }

	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 8
fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	xorps	xmm1, xmm1
	cvtss2sd xmm1, xmm0
	andpd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm1
	ret	0
fabsf	ENDP
_TEXT	ENDS
END
