; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	??0CTimer@@QAE@XZ				; CTimer::CTimer
PUBLIC	??1CTimer@@QAE@XZ				; CTimer::~CTimer
PUBLIC	?seed@RNG@@QAEXI@Z				; RNG::seed
PUBLIC	?randUint@RNG@@QAEIXZ				; RNG::randUint
PUBLIC	?randFloat@RNG@@QAEMXZ				; RNG::randFloat
PUBLIC	?randFloat@RNG@@QAEMMM@Z			; RNG::randFloat
PUBLIC	_main
PUBLIC	??$max@M@std@@YAABMABM0@Z			; std::max<float>
PUBLIC	?forceToMemory@@YAXPBX@Z			; forceToMemory
PUBLIC	??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@		; `string'
PUBLIC	??_C@_0CC@MHCKIHIN@calcWorldToCamera_FPU?5?$CFdM?5times?3@ ; `string'
PUBLIC	??_C@_0CG@LJFHOHJE@calcWorldToCamera_SSE_aos?5?$CFdM?5ti@ ; `string'
PUBLIC	??_C@_0DF@HEJBLKKF@Warning?3?5significant?5mismatch?5in@ ; `string'
PUBLIC	??_C@_0CL@PDOPMEAA@transformAABBs_FPU?0?5?$CFdK?5AABBs?0?5?$CF@ ; `string'
PUBLIC	??_C@_0CP@GOAMJCGE@transformAABBs_SSE_aos?0?5?$CFdK?5AABB@ ; `string'
PUBLIC	??_C@_0CP@MJCAKJJJ@transformAABBs_SSE_soa?0?5?$CFdK?5AABB@ ; `string'
PUBLIC	??_C@_0DG@FAFHICNP@Warning?3?5significant?5mismatch?5in@ ; `string'
PUBLIC	??_C@_0DG@JIIBKMLF@Warning?3?5significant?5mismatch?5in@ ; `string'
PUBLIC	__real@2f800000
PUBLIC	__real@3727c5ac
PUBLIC	__real@3f800000
PUBLIC	__real@40c00000
PUBLIC	__real@40c90fd0
PUBLIC	__real@41100000
PUBLIC	__real@41a00000
PUBLIC	__real@447a0000
PUBLIC	__real@c0400000
PUBLIC	__real@c1200000
PUBLIC	__xmm@0000000040400000400000003f800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__imp__printf:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	?calcWorldToCamera_FPU@@YAXMMQBMQAY03M@Z:PROC	; calcWorldToCamera_FPU
EXTRN	?calcWorldToCamera_SSE_aos@@YAXMMABT__m128@@QAT1@@Z:PROC ; calcWorldToCamera_SSE_aos
EXTRN	?transformAABBs_FPU@@YAXHPBUAABB@@QAY133$$CBMPAU1@@Z:PROC ; transformAABBs_FPU
EXTRN	?transformAABBs_SSE_aos@@YAXHPBUAABB_aos@@QAY03$$CBT__m128@@PAU1@@Z:PROC ; transformAABBs_SSE_aos
EXTRN	?transformAABBs_SSE_soa@@YAXHUAABBs_soa@@Umats_soa@@0@Z:PROC ; transformAABBs_SSE_soa
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@0000000040400000400000003f800000
CONST	SEGMENT
__xmm@0000000040400000400000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	'@', 00H, 00H, '@@', 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c0400000
CONST	SEGMENT
__real@c0400000 DD 0c0400000r			; -3
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@40c90fd0
CONST	SEGMENT
__real@40c90fd0 DD 040c90fd0r			; 6.28318
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@2f800000
CONST	SEGMENT
__real@2f800000 DD 02f800000r			; 2.32831e-010
CONST	ENDS
;	COMDAT ??_C@_0DG@JIIBKMLF@Warning?3?5significant?5mismatch?5in@
CONST	SEGMENT
??_C@_0DG@JIIBKMLF@Warning?3?5significant?5mismatch?5in@ DB 'Warning: sig'
	DB	'nificant mismatch in SOA bounding box %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FAFHICNP@Warning?3?5significant?5mismatch?5in@
CONST	SEGMENT
??_C@_0DG@FAFHICNP@Warning?3?5significant?5mismatch?5in@ DB 'Warning: sig'
	DB	'nificant mismatch in AOS bounding box %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MJCAKJJJ@transformAABBs_SSE_soa?0?5?$CFdK?5AABB@
CONST	SEGMENT
??_C@_0CP@MJCAKJJJ@transformAABBs_SSE_soa?0?5?$CFdK?5AABB@ DB 'transformA'
	DB	'ABBs_SSE_soa, %dK AABBs, %dK times: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GOAMJCGE@transformAABBs_SSE_aos?0?5?$CFdK?5AABB@
CONST	SEGMENT
??_C@_0CP@GOAMJCGE@transformAABBs_SSE_aos?0?5?$CFdK?5AABB@ DB 'transformA'
	DB	'ABBs_SSE_aos, %dK AABBs, %dK times: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PDOPMEAA@transformAABBs_FPU?0?5?$CFdK?5AABBs?0?5?$CF@
CONST	SEGMENT
??_C@_0CL@PDOPMEAA@transformAABBs_FPU?0?5?$CFdK?5AABBs?0?5?$CF@ DB 'trans'
	DB	'formAABBs_FPU, %dK AABBs, %dK times: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HEJBLKKF@Warning?3?5significant?5mismatch?5in@
CONST	SEGMENT
??_C@_0DF@HEJBLKKF@Warning?3?5significant?5mismatch?5in@ DB 'Warning: sig'
	DB	'nificant mismatch in component [%d][%d]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LJFHOHJE@calcWorldToCamera_SSE_aos?5?$CFdM?5ti@
CONST	SEGMENT
??_C@_0CG@LJFHOHJE@calcWorldToCamera_SSE_aos?5?$CFdM?5ti@ DB 'calcWorldTo'
	DB	'Camera_SSE_aos %dM times: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MHCKIHIN@calcWorldToCamera_FPU?5?$CFdM?5times?3@
CONST	SEGMENT
??_C@_0CC@MHCKIHIN@calcWorldToCamera_FPU?5?$CFdM?5times?3@ DB 'calcWorldT'
	DB	'oCamera_FPU %dM times: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
CONST	SEGMENT
??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@ DB '%0.1f ms', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$4
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?forceToMemory@@YAXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?forceToMemory@@YAXPBX@Z PROC				; forceToMemory, COMDAT

; 241  : }

	ret	0
?forceToMemory@@YAXPBX@Z ENDP				; forceToMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$max@M@std@@YAABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@M@std@@YAABMABM0@Z PROC				; std::max<float>, COMDAT

; 2031 : 	{	// return larger of _Left and _Right

	push	ebp
	mov	ebp, esp

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, DWORD PTR [eax]
	cmova	eax, ecx

; 2033 : 	}

	pop	ebp
	ret	0
??$max@M@std@@YAABMABM0@Z ENDP				; std::max<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT _main
_TEXT	SEGMENT
_cameraPos_aos$2 = -352512				; size = 16
_qpcFreq$3 = -352496					; size = 8
_qpcFreq$4 = -352488					; size = 8
_qpcFreq$5 = -352480					; size = 8
_qpcFreq$6 = -352472					; size = 8
_qpcFreq$7 = -352464					; size = 8
_outAABBs_soa$8 = -352456				; size = 24
_qpcEnd$9 = -352432					; size = 8
_timer$10 = -352424					; size = 8
_qpcEnd$11 = -352416					; size = 8
_qpcEnd$12 = -352408					; size = 8
_timer$13 = -352400					; size = 8
_timer$14 = -352392					; size = 8
_timer$15 = -352384					; size = 8
_timer$16 = -352376					; size = 8
_inAABBs_soa$17 = -352368				; size = 24
_qpcEnd$18 = -352344					; size = 8
_qpcEnd$19 = -352336					; size = 8
$T20 = -352328						; size = 4
$T21 = -352324						; size = 4
$T22 = -352320						; size = 4
$T23 = -352316						; size = 4
$T24 = -352312						; size = 4
$T25 = -352308						; size = 4
$T26 = -352304						; size = 4
$T27 = -352300						; size = 4
$T28 = -352296						; size = 4
$T29 = -352292						; size = 4
$T30 = -352288						; size = 4
$T31 = -352284						; size = 4
tv4118 = -352280					; size = 8
$T32 = -352276						; size = 4
tv3630 = -352272					; size = 4
_i$1$ = -352268						; size = 4
tv3629 = -352268					; size = 4
_absEpsilon$ = -352264					; size = 4
_i$1$ = -352260						; size = 4
tv3628 = -352260					; size = 4
tv4090 = -352256					; size = 8
tv3855 = -352256					; size = 8
tv3830 = -352256					; size = 8
tv3788 = -352256					; size = 8
tv3852 = -352252					; size = 4
tv3849 = -352252					; size = 4
tv3847 = -352252					; size = 4
tv3844 = -352252					; size = 4
tv3827 = -352252					; size = 4
tv3824 = -352252					; size = 4
tv3822 = -352252					; size = 4
tv3819 = -352252					; size = 4
tv3785 = -352252					; size = 4
tv3782 = -352252					; size = 4
tv3780 = -352252					; size = 4
tv3777 = -352252					; size = 4
tv3577 = -352252					; size = 4
_i$1$ = -352244						; size = 4
tv4115 = -352244					; size = 4
tv4112 = -352244					; size = 4
tv4110 = -352244					; size = 4
tv4107 = -352244					; size = 4
tv4087 = -352244					; size = 4
tv4084 = -352244					; size = 4
tv4082 = -352244					; size = 4
tv4079 = -352244					; size = 4
tv3625 = -352244					; size = 4
_theMats_soa$33 = -352240				; size = 64
_inAABBs$34 = -352176					; size = 24000
_mats$35 = -328176					; size = 64000
_outZMaxs$36 = -264176					; size = 4000
_outAABBs$37 = -260176					; size = 24000
_outYMaxs$38 = -236176					; size = 4000
_inYMins$39 = -232176					; size = 4000
_outXMaxs$40 = -228176					; size = 4000
_mats_aos$41 = -224176					; size = 64000
_outZMins$42 = -160176					; size = 4000
_inZMins$43 = -156176					; size = 4000
_outYMins$44 = -152176					; size = 4000
_inXMins$45 = -148176					; size = 4000
_inAABBs_aos$46 = -144176				; size = 32000
_outAABBs_aos$47 = -112176				; size = 32000
_outXMins$48 = -80176					; size = 4000
_inZMaxs$49 = -76176					; size = 4000
_inYMaxs$50 = -72176					; size = 4000
_inXMaxs$51 = -68176					; size = 4000
_matComps_soa$52 = -64176				; size = 64000
_worldToCamera$53 = -176				; size = 64
_worldToCamera_aos$54 = -112				; size = 64
_translate$55 = -44					; size = 12
_cameraPos$56 = -32					; size = 12
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 88   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	mov	eax, 352504				; 000560f8H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	movaps	xmm0, XMMWORD PTR __xmm@0000000040400000400000003f800000

; 89   : 	float absEpsilon = 1e-5f;
; 90   : 	float relEpsilon = 1e-5f;
; 91   : 
; 92   : 	{
; 93   : 		float yaw = 0.74f;
; 94   : 		float pitch = 0.47f;
; 95   : 		float cameraPos[] = { 1.0f, 2.0f, 3.0f };
; 96   : 		__m128 cameraPos_aos = { 1.0f, 2.0f, 3.0f };
; 97   : 		float worldToCamera[4][4];
; 98   : 		__m128 worldToCamera_aos[4];
; 99   : 
; 100  : #ifdef _DEBUG
; 101  : 		int trials = 1000000;
; 102  : #else
; 103  : 		int trials = 10000000;
; 104  : #endif
; 105  : 
; 106  : 		printf("calcWorldToCamera_FPU %dM times: ", trials/1000000);

	mov	esi, DWORD PTR __imp__printf
	push	10					; 0000000aH
	push	OFFSET ??_C@_0CC@MHCKIHIN@calcWorldToCamera_FPU?5?$CFdM?5times?3@
	mov	DWORD PTR _absEpsilon$[ebp], 925353388	; 3727c5acH
	mov	DWORD PTR _cameraPos$56[ebp], 1065353216 ; 3f800000H
	mov	DWORD PTR _cameraPos$56[ebp+4], 1073741824 ; 40000000H
	mov	DWORD PTR _cameraPos$56[ebp+8], 1077936128 ; 40400000H
	movaps	XMMWORD PTR _cameraPos_aos$2[ebp], xmm0
	call	esi
	add	esp, 8

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	eax, DWORD PTR _timer$14[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 107  : 		{
; 108  : 			CTimer timer;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edi, 10000000				; 00989680H
	npad	3
$LL44@main:

; 109  : 			for (int i = 0; i < trials; ++i)
; 110  : 				calcWorldToCamera_FPU(yaw, pitch, cameraPos, worldToCamera);

	lea	eax, DWORD PTR _worldToCamera$53[ebp]
	push	eax
	lea	eax, DWORD PTR _cameraPos$56[ebp]
	push	eax
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1055957975		; 3ef0a3d7H
	mov	DWORD PTR [esp], 1060991140		; 3f3d70a4H
	call	?calcWorldToCamera_FPU@@YAXMMQBMQAY03M@Z ; calcWorldToCamera_FPU
	add	esp, 16					; 00000010H
	dec	edi
	jne	SHORT $LL44@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	mov	edi, DWORD PTR __imp__QueryPerformanceCounter@4
	lea	eax, DWORD PTR _qpcEnd$18[ebp]
	push	eax
	call	edi

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	eax, DWORD PTR _qpcFreq$3[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	ecx, DWORD PTR _qpcEnd$18[ebp]
	sub	ecx, DWORD PTR _timer$14[ebp]
	mov	eax, DWORD PTR _qpcEnd$18[ebp+4]
	sbb	eax, DWORD PTR _timer$14[ebp+4]
	mov	DWORD PTR tv4118[ebp], ecx
	mov	DWORD PTR tv4118[ebp+4], eax
	fild	QWORD PTR tv4118[ebp]
	sub	esp, 8
	fstp	DWORD PTR tv4115[ebp]
	fld	DWORD PTR tv4115[ebp]
	fstp	DWORD PTR tv4112[ebp]
	movss	xmm0, DWORD PTR tv4112[ebp]
	fild	QWORD PTR _qpcFreq$3[ebp]
	fstp	DWORD PTR tv4110[ebp]
	fld	DWORD PTR tv4110[ebp]
	fstp	DWORD PTR tv4107[ebp]
	divss	xmm0, DWORD PTR tv4107[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	esi

; 111  : 		}
; 112  : 
; 113  : 		printf("calcWorldToCamera_SSE_aos %dM times: ", trials/1000000);

	push	10					; 0000000aH
	push	OFFSET ??_C@_0CG@LJFHOHJE@calcWorldToCamera_SSE_aos?5?$CFdM?5ti@
	call	esi
	add	esp, 20					; 00000014H

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	eax, DWORD PTR _timer$10[ebp]
	push	eax
	call	edi

; 114  : 		{
; 115  : 			CTimer timer;

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	mov	edi, 10000000				; 00989680H
$LL41@main:

; 116  : 			for (int i = 0; i < trials; ++i)
; 117  : 				calcWorldToCamera_SSE_aos(yaw, pitch, cameraPos_aos, worldToCamera_aos);

	lea	eax, DWORD PTR _worldToCamera_aos$54[ebp]
	push	eax
	lea	eax, DWORD PTR _cameraPos_aos$2[ebp]
	push	eax
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1055957975		; 3ef0a3d7H
	mov	DWORD PTR [esp], 1060991140		; 3f3d70a4H
	call	?calcWorldToCamera_SSE_aos@@YAXMMABT__m128@@QAT1@@Z ; calcWorldToCamera_SSE_aos
	add	esp, 16					; 00000010H
	dec	edi
	jne	SHORT $LL41@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	eax, DWORD PTR _qpcEnd$12[ebp]
	push	eax

; 118  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	eax, DWORD PTR _qpcFreq$7[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	ecx, DWORD PTR _qpcEnd$12[ebp]
	sub	ecx, DWORD PTR _timer$10[ebp]
	mov	eax, DWORD PTR _qpcEnd$12[ebp+4]
	sbb	eax, DWORD PTR _timer$10[ebp+4]
	mov	DWORD PTR tv4090[ebp], ecx
	mov	DWORD PTR tv4090[ebp+4], eax
	fild	QWORD PTR tv4090[ebp]
	sub	esp, 8
	fstp	DWORD PTR tv4087[ebp]
	fld	DWORD PTR tv4087[ebp]
	fstp	DWORD PTR tv4084[ebp]
	movss	xmm0, DWORD PTR tv4084[ebp]
	fild	QWORD PTR _qpcFreq$7[ebp]
	fstp	DWORD PTR tv4082[ebp]
	fld	DWORD PTR tv4082[ebp]
	fstp	DWORD PTR tv4079[ebp]
	divss	xmm0, DWORD PTR tv4079[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	esi

; 119  : 
; 120  : 		for (int i = 0; i < 4; ++i)

	movsd	xmm3, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	add	esp, 12					; 0000000cH

; 119  : 
; 120  : 		for (int i = 0; i < 4; ++i)

	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	npad	3
$LL38@main:
	movss	xmm4, DWORD PTR __real@3727c5ac
	mov	esi, ecx

; 121  : 		{
; 122  : 			for (int j = 0; j < 4; ++j)

	xor	edi, edi
	shl	esi, 4
	npad	1
$LL35@main:

; 125  : 						max(absEpsilon, relEpsilon * fabs(worldToCamera[i][j])))

	movss	xmm1, DWORD PTR _worldToCamera$53[ebp+esi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 125  : 						max(absEpsilon, relEpsilon * fabs(worldToCamera[i][j])))

	subss	xmm1, DWORD PTR _worldToCamera_aos$54[ebp+esi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 125  : 						max(absEpsilon, relEpsilon * fabs(worldToCamera[i][j])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	eax, DWORD PTR $T31[ebp]
	lea	edx, DWORD PTR _absEpsilon$[ebp]
	cmovbe	eax, edx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 125  : 						max(absEpsilon, relEpsilon * fabs(worldToCamera[i][j])))

	movss	DWORD PTR $T31[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN34@main

; 126  : 				{
; 127  : 					printf("Warning: significant mismatch in component [%d][%d]\n", i, j);

	push	edi
	push	ecx
	push	OFFSET ??_C@_0DF@HEJBLKKF@Warning?3?5significant?5mismatch?5in@
	call	DWORD PTR __imp__printf
	movsd	xmm3, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movss	xmm4, DWORD PTR __real@3727c5ac
	mov	ecx, DWORD PTR _i$1$[ebp]
	add	esp, 12					; 0000000cH
$LN34@main:

; 121  : 		{
; 122  : 			for (int j = 0; j < 4; ++j)

	inc	edi
	add	esi, 4
	cmp	edi, 4
	jl	SHORT $LL35@main

; 119  : 
; 120  : 		for (int i = 0; i < 4; ++i)

	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, 4
	jl	$LL38@main

; 128  : 				}
; 129  : 			}
; 130  : 		}
; 131  : 	}
; 132  : 
; 133  : 	{
; 134  : 		const int n = 1000;
; 135  : 		AABB inAABBs[n];
; 136  : 		float mats[n][4][4];
; 137  : 		AABB outAABBs[n];
; 138  : 
; 139  : 		AABB_aos inAABBs_aos[n];
; 140  : 		__m128 mats_aos[n][4];
; 141  : 		AABB_aos outAABBs_aos[n];
; 142  : 
; 143  : 		__m128 inXMins[n/4];
; 144  : 		__m128 inYMins[n/4];
; 145  : 		__m128 inZMins[n/4];
; 146  : 		__m128 inXMaxs[n/4];
; 147  : 		__m128 inYMaxs[n/4];
; 148  : 		__m128 inZMaxs[n/4];
; 149  : 		AABBs_soa inAABBs_soa = { inXMins, inYMins, inZMins, inXMaxs, inYMaxs, inZMaxs };

	lea	eax, DWORD PTR _inXMins$45[ebp]
	mov	DWORD PTR _inAABBs_soa$17[ebp], eax
	lea	eax, DWORD PTR _inYMins$39[ebp]
	mov	DWORD PTR _inAABBs_soa$17[ebp+4], eax
	lea	eax, DWORD PTR _inZMins$43[ebp]
	mov	DWORD PTR _inAABBs_soa$17[ebp+8], eax
	lea	eax, DWORD PTR _inXMaxs$51[ebp]
	mov	DWORD PTR _inAABBs_soa$17[ebp+12], eax
	lea	eax, DWORD PTR _inYMaxs$50[ebp]
	mov	DWORD PTR _inAABBs_soa$17[ebp+16], eax
	lea	eax, DWORD PTR _inZMaxs$49[ebp]
	mov	DWORD PTR _inAABBs_soa$17[ebp+20], eax
	lea	ecx, DWORD PTR _theMats_soa$33[ebp+4]
	lea	edx, DWORD PTR _matComps_soa$52[ebp+4000]
	mov	esi, 4
$LL31@main:

; 150  : 
; 151  : 		__m128 matComps_soa[4][4][n/4];
; 152  : 		mats_soa theMats_soa;
; 153  : 		for (int i = 0; i < 4; ++i)
; 154  : 			for (int j = 0; j < 4; ++j)
; 155  : 				theMats_soa.comps[i][j] = matComps_soa[i][j];

	lea	eax, DWORD PTR [edx-4000]
	mov	DWORD PTR [ecx-4], eax
	lea	eax, DWORD PTR [edx+4000]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx
	lea	eax, DWORD PTR [edx+8000]
	add	edx, 16000				; 00003e80H
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR [ecx+16]
	dec	esi
	jne	SHORT $LL31@main

; 156  : 
; 157  : 		__m128 outXMins[n/4];
; 158  : 		__m128 outYMins[n/4];
; 159  : 		__m128 outZMins[n/4];
; 160  : 		__m128 outXMaxs[n/4];
; 161  : 		__m128 outYMaxs[n/4];
; 162  : 		__m128 outZMaxs[n/4];
; 163  : 		AABBs_soa outAABBs_soa = { outXMins, outYMins, outZMins, outXMaxs, outYMaxs, outZMaxs };

	movss	xmm3, DWORD PTR __real@2f800000
	movss	xmm5, DWORD PTR __real@41a00000
	movss	xmm6, DWORD PTR __real@c1200000
	movss	xmm7, DWORD PTR __real@41100000
	lea	eax, DWORD PTR _outXMins$48[ebp]
	mov	DWORD PTR _outAABBs_soa$8[ebp], eax
	lea	eax, DWORD PTR _outYMins$44[ebp]
	mov	DWORD PTR _outAABBs_soa$8[ebp+4], eax
	lea	eax, DWORD PTR _outZMins$42[ebp]
	mov	DWORD PTR _outAABBs_soa$8[ebp+8], eax
	lea	eax, DWORD PTR _outXMaxs$40[ebp]
	mov	DWORD PTR _outAABBs_soa$8[ebp+12], eax
	lea	eax, DWORD PTR _outYMaxs$38[ebp]
	mov	DWORD PTR _outAABBs_soa$8[ebp+16], eax
	xorps	xmm4, xmm4
	lea	eax, DWORD PTR _outZMaxs$36[ebp]
	movaps	xmm2, xmm4
	subss	xmm2, DWORD PTR __real@40c90fd0
	mov	DWORD PTR _outAABBs_soa$8[ebp+20], eax
	lea	eax, DWORD PTR _inAABBs$34[ebp]

; 164  : 
; 165  : 		// Fill all three sets of inputs with some randomly generated data
; 166  : 		RNG rng;
; 167  : 		rng.seed(47);
; 168  : 		for (int i = 0; i < n; ++i)

	xor	edi, edi
	mov	DWORD PTR tv3629[ebp], eax
	xor	edx, edx
	lea	eax, DWORD PTR _inAABBs_aos$46[ebp+4]

; 48   : 	}
; 49   : };
; 50   : 
; 51   : // Quick simple RNG based on Xorhash
; 52   : struct RNG
; 53   : {
; 54   : 	unsigned int m_state;
; 55   : 
; 56   : 	void seed(unsigned int seed)
; 57   : 	{
; 58   : 		// Thomas Wang's integer hash, as reported by Bob Jenkins
; 59   : 		seed = (seed ^ 61) ^ (seed >> 16);
; 60   : 		seed *= 9;
; 61   : 		seed = seed ^ (seed >> 4);
; 62   : 		seed *= 0x27d4eb2d;
; 63   : 		seed = seed ^ (seed >> 15);
; 64   : 		m_state = seed;

	mov	esi, 599397116				; 23ba12fcH

; 164  : 
; 165  : 		// Fill all three sets of inputs with some randomly generated data
; 166  : 		RNG rng;
; 167  : 		rng.seed(47);
; 168  : 		for (int i = 0; i < n; ++i)

	mov	DWORD PTR _i$1$[ebp], edi
	movss	DWORD PTR tv3577[ebp], xmm2
	mov	DWORD PTR tv3630[ebp], edx
	mov	DWORD PTR tv3628[ebp], eax
$LL25@main:

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi
	shr	eax, 17					; 00000011H
	xor	esi, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	mov	eax, esi
	shr	eax, 31					; 0000001fH

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	movaps	xmm1, xmm6

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 169  : 		{
; 170  : 			inAABBs[i].mins[0] = inAABBs_aos[i].mins.m128_f32[0] = inXMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	mov	eax, DWORD PTR tv3628[ebp]
	mov	ecx, edi
	shr	ecx, 2
	and	edi, 3

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm0, xmm0

; 169  : 		{
; 170  : 			inAABBs[i].mins[0] = inAABBs_aos[i].mins.m128_f32[0] = inXMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	lea	edi, DWORD PTR [edi+ecx*4]

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mulss	xmm0, xmm3

; 169  : 		{
; 170  : 			inAABBs[i].mins[0] = inAABBs_aos[i].mins.m128_f32[0] = inXMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	mov	ecx, DWORD PTR tv3629[ebp]
	shl	edi, 2

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm5
	subss	xmm1, xmm0

; 169  : 		{
; 170  : 			inAABBs[i].mins[0] = inAABBs_aos[i].mins.m128_f32[0] = inXMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	movss	DWORD PTR [eax-4], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi
	shr	eax, 17					; 00000011H
	xor	esi, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	mov	eax, esi
	shr	eax, 31					; 0000001fH

; 169  : 		{
; 170  : 			inAABBs[i].mins[0] = inAABBs_aos[i].mins.m128_f32[0] = inXMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	movss	DWORD PTR _inXMins$45[ebp+edi], xmm1

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 171  : 			inAABBs[i].mins[1] = inAABBs_aos[i].mins.m128_f32[1] = inYMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	mov	eax, DWORD PTR tv3628[ebp]
	movss	DWORD PTR [ecx], xmm1

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	movaps	xmm1, xmm6

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm3

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm5
	subss	xmm1, xmm0

; 171  : 			inAABBs[i].mins[1] = inAABBs_aos[i].mins.m128_f32[1] = inYMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	movss	DWORD PTR [eax], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi
	shr	eax, 17					; 00000011H
	xor	esi, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	mov	eax, esi
	shr	eax, 31					; 0000001fH

; 171  : 			inAABBs[i].mins[1] = inAABBs_aos[i].mins.m128_f32[1] = inYMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	movss	DWORD PTR _inYMins$39[ebp+edi], xmm1

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 172  : 			inAABBs[i].mins[2] = inAABBs_aos[i].mins.m128_f32[2] = inZMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	mov	eax, DWORD PTR tv3628[ebp]
	movss	DWORD PTR [ecx+4], xmm1

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	movaps	xmm1, xmm6

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm3

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm5
	subss	xmm1, xmm0

; 172  : 			inAABBs[i].mins[2] = inAABBs_aos[i].mins.m128_f32[2] = inZMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	movss	DWORD PTR [eax+4], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi
	shr	eax, 17					; 00000011H

; 172  : 			inAABBs[i].mins[2] = inAABBs_aos[i].mins.m128_f32[2] = inZMins[i/4].m128_f32[i%4] = rng.randFloat(-10, 10);

	movss	DWORD PTR _inZMins$43[ebp+edi], xmm1
	movss	DWORD PTR [ecx+8], xmm1

; 71   : 		m_state ^= (m_state >> 17);

	xor	esi, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	mov	eax, esi
	shr	eax, 31					; 0000001fH

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	movss	xmm1, DWORD PTR __real@3f800000

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 173  : 			inAABBs[i].maxs[0] = inAABBs_aos[i].maxs.m128_f32[0] = inXMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[0] + rng.randFloat(1, 10);

	mov	eax, DWORD PTR tv3628[ebp]

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm3

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm7
	subss	xmm1, xmm0

; 173  : 			inAABBs[i].maxs[0] = inAABBs_aos[i].maxs.m128_f32[0] = inXMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[0] + rng.randFloat(1, 10);

	addss	xmm1, DWORD PTR [ecx]
	movss	DWORD PTR [eax+12], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi
	shr	eax, 17					; 00000011H
	xor	esi, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	mov	eax, esi
	shr	eax, 31					; 0000001fH

; 173  : 			inAABBs[i].maxs[0] = inAABBs_aos[i].maxs.m128_f32[0] = inXMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[0] + rng.randFloat(1, 10);

	movss	DWORD PTR _inXMaxs$51[ebp+edi], xmm1

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 174  : 			inAABBs[i].maxs[1] = inAABBs_aos[i].maxs.m128_f32[1] = inYMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[1] + rng.randFloat(1, 10);

	mov	eax, DWORD PTR tv3628[ebp]
	movss	DWORD PTR [ecx+12], xmm1

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	movss	xmm1, DWORD PTR __real@3f800000

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm3

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm7
	subss	xmm1, xmm0

; 174  : 			inAABBs[i].maxs[1] = inAABBs_aos[i].maxs.m128_f32[1] = inYMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[1] + rng.randFloat(1, 10);

	addss	xmm1, DWORD PTR [ecx+4]
	movss	DWORD PTR [eax+16], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi
	shr	eax, 17					; 00000011H
	xor	esi, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	mov	eax, esi
	shr	eax, 31					; 0000001fH

; 174  : 			inAABBs[i].maxs[1] = inAABBs_aos[i].maxs.m128_f32[1] = inYMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[1] + rng.randFloat(1, 10);

	movss	DWORD PTR _inYMaxs$50[ebp+edi], xmm1

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 175  : 			inAABBs[i].maxs[2] = inAABBs_aos[i].maxs.m128_f32[2] = inZMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[2] + rng.randFloat(1, 10);

	mov	eax, DWORD PTR tv3628[ebp]
	movss	DWORD PTR [ecx+16], xmm1

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	movss	xmm1, DWORD PTR __real@3f800000

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm3

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm7
	subss	xmm1, xmm0

; 175  : 			inAABBs[i].maxs[2] = inAABBs_aos[i].maxs.m128_f32[2] = inZMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[2] + rng.randFloat(1, 10);

	addss	xmm1, DWORD PTR [ecx+8]
	movss	DWORD PTR [eax+20], xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi
	shr	eax, 17					; 00000011H
	xor	esi, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	mov	eax, esi
	shr	eax, 31					; 0000001fH

; 175  : 			inAABBs[i].maxs[2] = inAABBs_aos[i].maxs.m128_f32[2] = inZMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[2] + rng.randFloat(1, 10);

	movss	DWORD PTR _inZMaxs$49[ebp+edi], xmm1

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 175  : 			inAABBs[i].maxs[2] = inAABBs_aos[i].maxs.m128_f32[2] = inZMaxs[i/4].m128_f32[i%4] = inAABBs[i].mins[2] + rng.randFloat(1, 10);

	movss	DWORD PTR [ecx+20], xmm1

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm1, xmm0

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mulss	xmm1, xmm3

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi
	shr	eax, 17					; 00000011H
	xor	esi, eax

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm1, xmm5

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	movaps	xmm0, xmm6
	subss	xmm0, xmm1

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, esi
	shr	eax, 31					; 0000001fH

; 176  : 
; 177  : 			float translate[] = { rng.randFloat(-10, 10), rng.randFloat(-10, 10), rng.randFloat(-10, 10) };

	movss	DWORD PTR _translate$55[ebp], xmm0
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm1, xmm0

; 71   : 		m_state ^= (m_state >> 17);

	shr	eax, 17					; 00000011H
	xor	esi, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mulss	xmm1, xmm3

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm1, xmm5
	movaps	xmm0, xmm6

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mov	eax, esi

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	subss	xmm0, xmm1

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	shr	eax, 31					; 0000001fH

; 176  : 
; 177  : 			float translate[] = { rng.randFloat(-10, 10), rng.randFloat(-10, 10), rng.randFloat(-10, 10) };

	movss	DWORD PTR _translate$55[ebp+4], xmm0
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm1, xmm0

; 71   : 		m_state ^= (m_state >> 17);

	shr	eax, 17					; 00000011H
	xor	esi, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mulss	xmm1, xmm3

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm1, xmm5
	movaps	xmm0, xmm6

; 73   : 		return m_state;

	mov	ecx, esi

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	subss	xmm0, xmm1

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	eax, esi
	shl	eax, 13					; 0000000dH
	xor	esi, eax

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, esi

; 176  : 
; 177  : 			float translate[] = { rng.randFloat(-10, 10), rng.randFloat(-10, 10), rng.randFloat(-10, 10) };

	movss	DWORD PTR _translate$55[ebp+8], xmm0
	movd	xmm0, ecx

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH

; 71   : 		m_state ^= (m_state >> 17);

	shr	eax, 17					; 00000011H

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]

; 71   : 		m_state ^= (m_state >> 17);

	xor	esi, eax

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	esi, eax

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtpd2ps xmm1, xmm0

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	movss	xmm0, DWORD PTR __real@c0400000

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	mulss	xmm1, xmm3

; 164  : 
; 165  : 		// Fill all three sets of inputs with some randomly generated data
; 166  : 		RNG rng;
; 167  : 		rng.seed(47);
; 168  : 		for (int i = 0; i < n; ++i)

	lea	eax, DWORD PTR _mats$35[ebp]
	add	eax, edx

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm1, DWORD PTR __real@40c00000

; 178  : 			calcWorldToCamera_FPU(rng.randFloat(0, 2.0f*3.14159f), rng.randFloat(-3.0f, 3.0f), translate, mats[i]);

	push	eax
	lea	eax, DWORD PTR _translate$55[ebp]

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	subss	xmm0, xmm1

; 178  : 			calcWorldToCamera_FPU(rng.randFloat(0, 2.0f*3.14159f), rng.randFloat(-3.0f, 3.0f), translate, mats[i]);

	push	eax
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, esi

; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0
	mov	eax, esi
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm3

; 79   : 	}
; 80   : 
; 81   : 	float randFloat(float min, float max)
; 82   : 	{
; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm0, xmm2
	addss	xmm0, xmm4

; 178  : 			calcWorldToCamera_FPU(rng.randFloat(0, 2.0f*3.14159f), rng.randFloat(-3.0f, 3.0f), translate, mats[i]);

	movss	DWORD PTR [esp], xmm0
	call	?calcWorldToCamera_FPU@@YAXMMQBMQAY03M@Z ; calcWorldToCamera_FPU

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	edx, DWORD PTR tv3630[ebp]
	lea	eax, DWORD PTR _matComps_soa$52[ebp]

; 178  : 			calcWorldToCamera_FPU(rng.randFloat(0, 2.0f*3.14159f), rng.randFloat(-3.0f, 3.0f), translate, mats[i]);

	add	esp, 16					; 00000010H

; 65   : 	}
; 66   : 
; 67   : 	unsigned int randUint()
; 68   : 	{
; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	add	eax, edi
	mov	edi, 4
	npad	2
$LL22@main:

; 180  : 				for (int k = 0; k < 4; ++k)

	mov	ecx, 4
$LL19@main:

; 181  : 					matComps_soa[j][k][i/4].m128_f32[i%4] = mats_aos[i][j].m128_f32[k] = mats[i][j][k];

	movss	xmm0, DWORD PTR _mats$35[ebp+edx]
	movss	DWORD PTR _mats_aos$41[ebp+edx], xmm0
	movss	DWORD PTR [eax], xmm0
	add	edx, 4
	add	eax, 4000				; 00000fa0H
	dec	ecx
	jne	SHORT $LL19@main

; 179  : 			for (int j = 0; j < 4; ++j)

	mov	DWORD PTR tv3630[ebp], edx
	dec	edi
	jne	SHORT $LL22@main

; 164  : 
; 165  : 		// Fill all three sets of inputs with some randomly generated data
; 166  : 		RNG rng;
; 167  : 		rng.seed(47);
; 168  : 		for (int i = 0; i < n; ++i)

	mov	edi, DWORD PTR _i$1$[ebp]
	add	DWORD PTR tv3628[ebp], 32		; 00000020H
	add	DWORD PTR tv3629[ebp], 24		; 00000018H
	movss	xmm2, DWORD PTR tv3577[ebp]
	movss	xmm3, DWORD PTR __real@2f800000
	movss	xmm5, DWORD PTR __real@41a00000
	movss	xmm6, DWORD PTR __real@c1200000
	movss	xmm7, DWORD PTR __real@41100000
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	xorps	xmm4, xmm4
	cmp	edx, 64000				; 0000fa00H
	jl	$LL25@main

; 182  : 		}
; 183  : 
; 184  : #ifdef _DEBUG
; 185  : 		int trials = 100;
; 186  : #else
; 187  : 		int trials = 10000;
; 188  : #endif
; 189  : 
; 190  : 		printf("transformAABBs_FPU, %dK AABBs, %dK times: ", n/1000, trials/1000);

	mov	esi, DWORD PTR __imp__printf
	push	10					; 0000000aH
	push	1
	push	OFFSET ??_C@_0CL@PDOPMEAA@transformAABBs_FPU?0?5?$CFdK?5AABBs?0?5?$CF@
	call	esi
	add	esp, 12					; 0000000cH

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	eax, DWORD PTR _timer$15[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 191  : 		{
; 192  : 			CTimer timer;

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edi, 10000				; 00002710H
	npad	2
$LL16@main:

; 193  : 			for (int i = 0; i < trials; ++i)
; 194  : 				transformAABBs_FPU(n, inAABBs, mats, outAABBs);

	lea	eax, DWORD PTR _outAABBs$37[ebp]
	push	eax
	lea	eax, DWORD PTR _mats$35[ebp]
	push	eax
	lea	eax, DWORD PTR _inAABBs$34[ebp]
	push	eax
	push	1000					; 000003e8H
	call	?transformAABBs_FPU@@YAXHPBUAABB@@QAY133$$CBMPAU1@@Z ; transformAABBs_FPU
	add	esp, 16					; 00000010H
	dec	edi
	jne	SHORT $LL16@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	mov	edi, DWORD PTR __imp__QueryPerformanceCounter@4
	lea	eax, DWORD PTR _qpcEnd$9[ebp]
	push	eax
	call	edi

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	eax, DWORD PTR _qpcFreq$4[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	ecx, DWORD PTR _qpcEnd$9[ebp]
	sub	ecx, DWORD PTR _timer$15[ebp]
	mov	eax, DWORD PTR _qpcEnd$9[ebp+4]
	sbb	eax, DWORD PTR _timer$15[ebp+4]
	mov	DWORD PTR tv3855[ebp], ecx
	mov	DWORD PTR tv3855[ebp+4], eax
	fild	QWORD PTR tv3855[ebp]
	sub	esp, 8
	fstp	DWORD PTR tv3852[ebp]
	fld	DWORD PTR tv3852[ebp]
	fstp	DWORD PTR tv3849[ebp]
	movss	xmm0, DWORD PTR tv3849[ebp]
	fild	QWORD PTR _qpcFreq$4[ebp]
	fstp	DWORD PTR tv3847[ebp]
	fld	DWORD PTR tv3847[ebp]
	fstp	DWORD PTR tv3844[ebp]
	divss	xmm0, DWORD PTR tv3844[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	esi

; 195  : 		}
; 196  : 
; 197  : 		printf("transformAABBs_SSE_aos, %dK AABBs, %dK times: ", n/1000, trials/1000);

	push	10					; 0000000aH
	push	1
	push	OFFSET ??_C@_0CP@GOAMJCGE@transformAABBs_SSE_aos?0?5?$CFdK?5AABB@
	call	esi
	add	esp, 24					; 00000018H

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	eax, DWORD PTR _timer$13[ebp]
	push	eax
	call	edi

; 198  : 		{
; 199  : 			CTimer timer;

	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	mov	edi, 10000				; 00002710H
$LL13@main:

; 200  : 			for (int i = 0; i < trials; ++i)
; 201  : 				transformAABBs_SSE_aos(n, inAABBs_aos, mats_aos, outAABBs_aos);

	lea	eax, DWORD PTR _outAABBs_aos$47[ebp]
	push	eax
	lea	eax, DWORD PTR _mats_aos$41[ebp]
	push	eax
	lea	eax, DWORD PTR _inAABBs_aos$46[ebp]
	push	eax
	push	1000					; 000003e8H
	call	?transformAABBs_SSE_aos@@YAXHPBUAABB_aos@@QAY03$$CBT__m128@@PAU1@@Z ; transformAABBs_SSE_aos
	add	esp, 16					; 00000010H
	dec	edi
	jne	SHORT $LL13@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	mov	edi, DWORD PTR __imp__QueryPerformanceCounter@4
	lea	eax, DWORD PTR _qpcEnd$11[ebp]
	push	eax
	call	edi

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	eax, DWORD PTR _qpcFreq$5[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	ecx, DWORD PTR _qpcEnd$11[ebp]
	sub	ecx, DWORD PTR _timer$13[ebp]
	mov	eax, DWORD PTR _qpcEnd$11[ebp+4]
	sbb	eax, DWORD PTR _timer$13[ebp+4]
	mov	DWORD PTR tv3830[ebp], ecx
	mov	DWORD PTR tv3830[ebp+4], eax
	fild	QWORD PTR tv3830[ebp]
	sub	esp, 8
	fstp	DWORD PTR tv3827[ebp]
	fld	DWORD PTR tv3827[ebp]
	fstp	DWORD PTR tv3824[ebp]
	movss	xmm0, DWORD PTR tv3824[ebp]
	fild	QWORD PTR _qpcFreq$5[ebp]
	fstp	DWORD PTR tv3822[ebp]
	fld	DWORD PTR tv3822[ebp]
	fstp	DWORD PTR tv3819[ebp]
	divss	xmm0, DWORD PTR tv3819[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	esi

; 202  : 		}
; 203  : 
; 204  : 		printf("transformAABBs_SSE_soa, %dK AABBs, %dK times: ", n/1000, trials/1000);

	push	10					; 0000000aH
	push	1
	push	OFFSET ??_C@_0CP@MJCAKJJJ@transformAABBs_SSE_soa?0?5?$CFdK?5AABB@
	call	esi
	add	esp, 24					; 00000018H

; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	lea	eax, DWORD PTR _timer$16[ebp]
	push	eax
	call	edi

; 205  : 		{
; 206  : 			CTimer timer;

	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	mov	DWORD PTR tv3625[ebp], 10000		; 00002710H
	npad	7
$LL10@main:

; 207  : 			for (int i = 0; i < trials; ++i)
; 208  : 				transformAABBs_SSE_soa(n, inAABBs_soa, theMats_soa, outAABBs_soa);

	movq	xmm0, QWORD PTR _outAABBs_soa$8[ebp]
	sub	esp, 24					; 00000018H
	mov	eax, esp
	sub	esp, 64					; 00000040H
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR _outAABBs_soa$8[ebp+8]
	movq	QWORD PTR [eax+8], xmm0
	movq	xmm0, QWORD PTR _outAABBs_soa$8[ebp+16]
	movq	QWORD PTR [eax+16], xmm0
	movq	xmm0, QWORD PTR _inAABBs_soa$17[ebp]
	mov	edi, esp
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	ecx, 16					; 00000010H
	lea	esi, DWORD PTR _theMats_soa$33[ebp]
	rep movsd
	movq	QWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR _inAABBs_soa$17[ebp+8]
	movq	QWORD PTR [eax+8], xmm0
	movq	xmm0, QWORD PTR _inAABBs_soa$17[ebp+16]
	push	1000					; 000003e8H
	movq	QWORD PTR [eax+16], xmm0
	call	?transformAABBs_SSE_soa@@YAXHUAABBs_soa@@Umats_soa@@0@Z ; transformAABBs_SSE_soa
	add	esp, 116				; 00000074H
	dec	DWORD PTR tv3625[ebp]
	jne	SHORT $LL10@main

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	eax, DWORD PTR _qpcEnd$19[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	eax, DWORD PTR _qpcFreq$6[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	ecx, DWORD PTR _qpcEnd$19[ebp]
	sub	ecx, DWORD PTR _timer$16[ebp]
	mov	eax, DWORD PTR _qpcEnd$19[ebp+4]
	sbb	eax, DWORD PTR _timer$16[ebp+4]
	mov	DWORD PTR tv3788[ebp], ecx
	mov	DWORD PTR tv3788[ebp+4], eax
	fild	QWORD PTR tv3788[ebp]
	sub	esp, 8
	fstp	DWORD PTR tv3785[ebp]
	fld	DWORD PTR tv3785[ebp]
	fstp	DWORD PTR tv3782[ebp]
	movss	xmm0, DWORD PTR tv3782[ebp]
	fild	QWORD PTR _qpcFreq$6[ebp]
	fstp	DWORD PTR tv3780[ebp]
	fld	DWORD PTR tv3780[ebp]
	fstp	DWORD PTR tv3777[ebp]
	divss	xmm0, DWORD PTR tv3777[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	DWORD PTR __imp__printf
	movsd	xmm3, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movss	xmm4, DWORD PTR __real@3727c5ac
	add	esp, 12					; 0000000cH

; 209  : 		}
; 210  : 
; 211  : 		for (int i = 0; i < n; ++i)

	xor	edx, edx
	mov	DWORD PTR _i$1$[ebp], edx

; 41   : 	}
; 42   : 	~CTimer()
; 43   : 	{
; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	esi, DWORD PTR _outAABBs$37[ebp+4]
	lea	edi, DWORD PTR _outAABBs_aos$47[ebp+4]
$LL7@main:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi-4]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR [edi-4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	eax, DWORD PTR $T29[ebp]
	lea	ecx, DWORD PTR _absEpsilon$[ebp]
	cmovbe	eax, ecx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	movss	DWORD PTR $T29[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	$LN3@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	eax, DWORD PTR $T21[ebp]
	cmovbe	eax, ecx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	movss	DWORD PTR $T21[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	$LN3@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi+4]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	eax, DWORD PTR $T27[ebp]
	cmovbe	eax, ecx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	movss	DWORD PTR $T27[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	$LN3@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi+8]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	eax, DWORD PTR $T23[ebp]
	cmovbe	eax, ecx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	movss	DWORD PTR $T23[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	$LN3@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi+12]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	eax, DWORD PTR $T30[ebp]
	cmovbe	eax, ecx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	movss	DWORD PTR $T30[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	SHORT $LN3@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi+16]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR [edi+20]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	eax, DWORD PTR $T28[ebp]
	cmovbe	eax, ecx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 218  : 				fabs(outAABBs[i].maxs[2] - outAABBs_aos[i].maxs.m128_f32[2]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	movss	DWORD PTR $T28[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN4@main
$LN3@main:

; 219  : 			{
; 220  : 				printf("Warning: significant mismatch in AOS bounding box %d\n", i);

	push	edx
	push	OFFSET ??_C@_0DG@FAFHICNP@Warning?3?5significant?5mismatch?5in@
	call	DWORD PTR __imp__printf
	movsd	xmm3, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movss	xmm4, DWORD PTR __real@3727c5ac
	mov	edx, DWORD PTR _i$1$[ebp]
	add	esp, 8
$LN4@main:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi-4]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mov	ecx, edx
	and	edx, 3
	shr	ecx, 2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	lea	ecx, DWORD PTR [edx+ecx*4]
	mulss	xmm2, xmm4
	subss	xmm1, DWORD PTR _outXMins$48[ebp+ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR _absEpsilon$[ebp]
	comiss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T26[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovbe	eax, edx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mov	edx, DWORD PTR _i$1$[ebp]
	movss	DWORD PTR $T26[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	$LN1@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR _outYMins$44[ebp+ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	edx, DWORD PTR _absEpsilon$[ebp]
	lea	eax, DWORD PTR $T24[ebp]
	cmovbe	eax, edx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mov	edx, DWORD PTR _i$1$[ebp]
	movss	DWORD PTR $T24[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	$LN1@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi+4]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR _outZMins$42[ebp+ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	edx, DWORD PTR _absEpsilon$[ebp]
	lea	eax, DWORD PTR $T22[ebp]
	cmovbe	eax, edx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mov	edx, DWORD PTR _i$1$[ebp]
	movss	DWORD PTR $T22[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	$LN1@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi+8]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR _outXMaxs$40[ebp+ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	edx, DWORD PTR _absEpsilon$[ebp]
	lea	eax, DWORD PTR $T20[ebp]
	cmovbe	eax, edx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mov	edx, DWORD PTR _i$1$[ebp]
	movss	DWORD PTR $T20[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	$LN1@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi+12]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR _outYMaxs$38[ebp+ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	edx, DWORD PTR _absEpsilon$[ebp]
	lea	eax, DWORD PTR $T25[ebp]
	cmovbe	eax, edx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mov	edx, DWORD PTR _i$1$[ebp]
	movss	DWORD PTR $T25[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	ja	SHORT $LN1@main
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	movss	xmm1, DWORD PTR [esi+16]
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	subss	xmm1, DWORD PTR _outZMaxs$36[ebp+ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm1
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	mulss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 392  :         {return ((float)fabs((double)_X)); }

	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2032 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	comiss	xmm2, xmm4
	lea	eax, DWORD PTR $T32[ebp]
	lea	ecx, DWORD PTR _absEpsilon$[ebp]
	cmovbe	eax, ecx
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp

; 227  : 				fabs(outAABBs[i].maxs[2] - outZMaxs[i/4].m128_f32[i%4]) > max(absEpsilon, relEpsilon * fabs(outAABBs[i].maxs[2])))

	movss	DWORD PTR $T32[ebp], xmm2
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN6@main
$LN1@main:

; 228  : 			{
; 229  : 				printf("Warning: significant mismatch in SOA bounding box %d\n", i);

	push	edx
	push	OFFSET ??_C@_0DG@JIIBKMLF@Warning?3?5significant?5mismatch?5in@
	call	DWORD PTR __imp__printf
	movsd	xmm3, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movss	xmm4, DWORD PTR __real@3727c5ac
	mov	edx, DWORD PTR _i$1$[ebp]
	add	esp, 8
$LN6@main:

; 209  : 		}
; 210  : 
; 211  : 		for (int i = 0; i < n; ++i)

	inc	edx
	add	edi, 32					; 00000020H
	add	esi, 24					; 00000018H
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	edx, 1000				; 000003e8H
	jl	$LL7@main

; 230  : 			}
; 231  : 		}
; 232  : 	}
; 233  : 
; 234  : 	return 0;

	xor	eax, eax

; 235  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
	lea	ecx, DWORD PTR _timer$14[ebp]
	jmp	??1CTimer@@QAE@XZ			; CTimer::~CTimer
__unwindfunclet$_main$1:
	lea	ecx, DWORD PTR _timer$10[ebp]
	jmp	??1CTimer@@QAE@XZ			; CTimer::~CTimer
__unwindfunclet$_main$2:
	lea	ecx, DWORD PTR _timer$15[ebp]
	jmp	??1CTimer@@QAE@XZ			; CTimer::~CTimer
__unwindfunclet$_main$3:
	lea	ecx, DWORD PTR _timer$13[ebp]
	jmp	??1CTimer@@QAE@XZ			; CTimer::~CTimer
__unwindfunclet$_main$4:
	lea	ecx, DWORD PTR _timer$16[ebp]
	jmp	??1CTimer@@QAE@XZ			; CTimer::~CTimer
__ehhandler$_main:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-352520]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?randFloat@RNG@@QAEMMM@Z
_TEXT	SEGMENT
tv147 = 8						; size = 4
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?randFloat@RNG@@QAEMMM@Z PROC				; RNG::randFloat, COMDAT
; _this$ = ecx

; 82   : 	{

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 83   : 		return min + (min - max)*randFloat();

	movss	xmm2, DWORD PTR _min$[ebp]

; 70   : 		m_state ^= (m_state << 13);

	mov	edx, DWORD PTR [esi]
	shl	edx, 13					; 0000000dH
	xor	edx, DWORD PTR [esi]

; 83   : 		return min + (min - max)*randFloat();

	subss	xmm2, DWORD PTR _max$[ebp]

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, edx
	shr	eax, 17					; 00000011H
	xor	eax, edx

; 72   : 		m_state ^= (m_state << 5);

	mov	ecx, eax
	shl	ecx, 5
	xor	ecx, eax
	movd	xmm0, ecx

; 73   : 		return m_state;
; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0

; 72   : 		m_state ^= (m_state << 5);

	mov	DWORD PTR [esi], ecx

; 73   : 		return m_state;
; 74   : 	}
; 75   : 
; 76   : 	float randFloat()
; 77   : 	{
; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	shr	ecx, 31					; 0000001fH
	pop	esi
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@2f800000

; 83   : 		return min + (min - max)*randFloat();

	mulss	xmm2, xmm0
	addss	xmm2, DWORD PTR _min$[ebp]
	movss	DWORD PTR tv147[ebp], xmm2
	fld	DWORD PTR tv147[ebp]

; 84   : 	}

	pop	ebp
	ret	8
?randFloat@RNG@@QAEMMM@Z ENDP				; RNG::randFloat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?randFloat@RNG@@QAEMXZ
_TEXT	SEGMENT
tv140 = -4						; size = 4
?randFloat@RNG@@QAEMXZ PROC				; RNG::randFloat, COMDAT
; _this$ = ecx

; 77   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 70   : 		m_state ^= (m_state << 13);

	mov	edx, DWORD PTR [esi]
	shl	edx, 13					; 0000000dH
	xor	edx, DWORD PTR [esi]

; 71   : 		m_state ^= (m_state >> 17);

	mov	eax, edx
	shr	eax, 17					; 00000011H
	xor	eax, edx

; 72   : 		m_state ^= (m_state << 5);

	mov	ecx, eax
	shl	ecx, 5
	xor	ecx, eax
	movd	xmm0, ecx

; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	cvtdq2pd xmm0, xmm0

; 72   : 		m_state ^= (m_state << 5);

	mov	DWORD PTR [esi], ecx

; 78   : 		return float(randUint()) * (1.0f / 4294967296.0f);

	shr	ecx, 31					; 0000001fH
	pop	esi
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@2f800000
	movss	DWORD PTR tv140[ebp], xmm0
	fld	DWORD PTR tv140[ebp]

; 79   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?randFloat@RNG@@QAEMXZ ENDP				; RNG::randFloat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?randUint@RNG@@QAEIXZ
_TEXT	SEGMENT
?randUint@RNG@@QAEIXZ PROC				; RNG::randUint, COMDAT
; _this$ = ecx

; 69   : 		// Xorshift algorithm from George Marsaglia's paper
; 70   : 		m_state ^= (m_state << 13);

	mov	edx, DWORD PTR [ecx]
	shl	edx, 13					; 0000000dH
	xor	edx, DWORD PTR [ecx]
	push	esi

; 71   : 		m_state ^= (m_state >> 17);

	mov	esi, edx
	shr	esi, 17					; 00000011H
	xor	esi, edx

; 72   : 		m_state ^= (m_state << 5);

	mov	eax, esi
	shl	eax, 5
	xor	eax, esi
	mov	DWORD PTR [ecx], eax
	pop	esi

; 73   : 		return m_state;
; 74   : 	}

	ret	0
?randUint@RNG@@QAEIXZ ENDP				; RNG::randUint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ?seed@RNG@@QAEXI@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?seed@RNG@@QAEXI@Z PROC					; RNG::seed, COMDAT
; _this$ = ecx

; 57   : 	{

	push	ebp
	mov	ebp, esp

; 58   : 		// Thomas Wang's integer hash, as reported by Bob Jenkins
; 59   : 		seed = (seed ^ 61) ^ (seed >> 16);
; 60   : 		seed *= 9;

	mov	edx, DWORD PTR _seed$[ebp]
	xor	edx, 3997696				; 003d0000H
	shr	edx, 16					; 00000010H
	xor	edx, DWORD PTR _seed$[ebp]
	push	esi
	mov	esi, ecx
	lea	eax, DWORD PTR [edx+edx*8]

; 61   : 		seed = seed ^ (seed >> 4);

	mov	ecx, eax
	shr	ecx, 4
	xor	ecx, eax

; 62   : 		seed *= 0x27d4eb2d;

	imul	ecx, 668265261				; 27d4eb2dH

; 63   : 		seed = seed ^ (seed >> 15);

	mov	eax, ecx
	shr	eax, 15					; 0000000fH
	xor	eax, ecx

; 64   : 		m_state = seed;

	mov	DWORD PTR [esi], eax
	pop	esi

; 65   : 	}

	pop	ebp
	ret	4
?seed@RNG@@QAEXI@Z ENDP					; RNG::seed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ??1CTimer@@QAE@XZ
_TEXT	SEGMENT
_qpcFreq$ = -24						; size = 8
_qpcEnd$ = -16						; size = 8
tv67 = -8						; size = 8
tv89 = -4						; size = 4
tv86 = -4						; size = 4
tv84 = -4						; size = 4
tv79 = -4						; size = 4
??1CTimer@@QAE@XZ PROC					; CTimer::~CTimer, COMDAT
; _this$ = ecx

; 43   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 44   : 		__int64 qpcEnd, qpcFreq;
; 45   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcEnd);

	lea	eax, DWORD PTR _qpcEnd$[ebp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 46   : 		QueryPerformanceFrequency((LARGE_INTEGER *)&qpcFreq);

	lea	eax, DWORD PTR _qpcFreq$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 47   : 		printf("%0.1f ms\n", float(qpcEnd - qpcStart) / float(qpcFreq) * 1000.0f);

	mov	edx, DWORD PTR _qpcEnd$[ebp]
	sub	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _qpcEnd$[ebp+4]
	sbb	eax, DWORD PTR [esi+4]
	mov	DWORD PTR tv67[ebp], edx
	mov	DWORD PTR tv67[ebp+4], eax
	fild	QWORD PTR tv67[ebp]
	sub	esp, 8
	fstp	DWORD PTR tv79[ebp]
	fld	DWORD PTR tv79[ebp]
	fstp	DWORD PTR tv84[ebp]
	movss	xmm0, DWORD PTR tv84[ebp]
	fild	QWORD PTR _qpcFreq$[ebp]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	fstp	DWORD PTR tv89[ebp]
	divss	xmm0, DWORD PTR tv89[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09DKAJDFD@?$CF0?41f?5ms?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	pop	esi

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1CTimer@@QAE@XZ ENDP					; CTimer::~CTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\source\reed-util\fpu-vs-sse\fpu-vs-sse.cpp
;	COMDAT ??0CTimer@@QAE@XZ
_TEXT	SEGMENT
??0CTimer@@QAE@XZ PROC					; CTimer::CTimer, COMDAT
; _this$ = ecx

; 38   : 	CTimer()

	push	esi
	mov	esi, ecx

; 39   : 	{
; 40   : 		QueryPerformanceCounter((LARGE_INTEGER *)&qpcStart);

	push	esi
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 41   : 	}

	mov	eax, esi
	pop	esi
	ret	0
??0CTimer@@QAE@XZ ENDP					; CTimer::CTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv74 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 392  :         {return ((float)fabs((double)_X)); }

	cvtps2pd xmm0, xmm0
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0

; 517  :         {return (fabsf(_X)); }

	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv70 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]
	cvtps2pd xmm0, xmm0
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
	fld	DWORD PTR tv70[ebp]
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
END
